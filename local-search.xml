<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>mysql</title>
    <link href="/2021/05/18/mysql/"/>
    <url>/2021/05/18/mysql/</url>
    
    <content type="html"><![CDATA[<h2 id="本单元目标"><a href="#本单元目标" class="headerlink" title="本单元目标"></a>本单元目标</h2><div class="hljs code-wrapper"><pre><code>一、为什么要学习数据库二、数据库的相关概念          DBMS、DB、SQL三、数据库存储数据的特点四、初始MySQL    MySQL产品的介绍            MySQL产品的安装          ★            MySQL服务的启动和停止     ★    MySQL服务的登录和退出     ★          MySQL的常见命令和语法规范      五、DQL语言的学习   ★                  基础查询        ★                 条件查询         ★                排序查询         ★                    常见函数        ★                   分组函数        ★                  分组查询           ★                连接查询         ★                子查询       √                      分页查询       ★                  union联合查询    √                六、DML语言的学习    ★                 插入语句                            修改语句                            删除语句                        七、DDL语言的学习      库和表的管理     √                    常见数据类型介绍  √              常见约束        √            八、TCL语言的学习    事务和事务处理                 九、视图的讲解           √十、变量                      十一、存储过程和函数   十二、流程控制结构       </code></pre></div><h2 id="数据库的好处"><a href="#数据库的好处" class="headerlink" title="数据库的好处"></a>数据库的好处</h2><div class="hljs code-wrapper"><pre><code>1.持久化数据到本地2.可以实现结构化查询，方便管理</code></pre></div><h2 id="数据库相关概念"><a href="#数据库相关概念" class="headerlink" title="数据库相关概念"></a>数据库相关概念</h2><div class="hljs code-wrapper"><pre><code>1、DB：数据库，保存一组有组织的数据的容器2、DBMS：数据库管理系统，又称为数据库软件（产品），用于管理DB中的数据3、SQL:结构化查询语言，用于和DBMS通信的语言</code></pre></div><h2 id="数据库存储数据的特点"><a href="#数据库存储数据的特点" class="headerlink" title="数据库存储数据的特点"></a>数据库存储数据的特点</h2><div class="hljs code-wrapper"><pre><code>1、将数据放到表中，表再放到库中2、一个数据库中可以有多个表，每个表都有一个的名字，用来标识自己。表名具有唯一性。3、表具有一些特性，这些特性定义了数据在表中如何存储，类似java中 “类”的设计。4、表由列组成，我们也称为字段。所有表都是由一个或多个列组成的，每一列类似java 中的”属性”5、表中的数据是按行存储的，每一行类似于java中的“对象”。</code></pre></div><h2 id="MySQL产品的介绍和安装"><a href="#MySQL产品的介绍和安装" class="headerlink" title="MySQL产品的介绍和安装"></a>MySQL产品的介绍和安装</h2><h3 id="MySQL服务的启动和停止"><a href="#MySQL服务的启动和停止" class="headerlink" title="MySQL服务的启动和停止"></a>MySQL服务的启动和停止</h3><div class="hljs code-wrapper"><pre><code>方式一：计算机——右击管理——服务方式二：通过管理员身份运行net start 服务名（启动服务）net stop 服务名（停止服务）</code></pre></div><h3 id="MySQL服务的登录和退出"><a href="#MySQL服务的登录和退出" class="headerlink" title="MySQL服务的登录和退出"></a>MySQL服务的登录和退出</h3><div class="hljs code-wrapper"><pre><code>方式一：通过mysql自带的客户端只限于root用户方式二：通过windows自带的客户端登录：mysql 【-h主机名 -P端口号 】-u用户名 -p密码退出：exit或ctrl+C</code></pre></div><p>​<br>​<br>​    </p><h3 id="MySQL的常见命令"><a href="#MySQL的常见命令" class="headerlink" title="MySQL的常见命令"></a>MySQL的常见命令</h3><div class="hljs code-wrapper"><pre><code>1.查看当前所有的数据库show databases;2.打开指定的库use 库名3.查看当前库的所有表show tables;4.查看其它库的所有表show tables from 库名;5.创建表create table 表名(    列名 列类型,    列名 列类型，    。。。);6.查看表结构desc 表名;7.查看服务器的版本方式一：登录到mysql服务端select version();方式二：没有登录到mysql服务端mysql --version或mysql --V</code></pre></div><h3 id="MySQL的语法规范"><a href="#MySQL的语法规范" class="headerlink" title="MySQL的语法规范"></a>MySQL的语法规范</h3><div class="hljs code-wrapper"><pre><code>1.不区分大小写,但建议关键字大写，表名、列名小写2.每条命令最好用分号结尾3.每条命令根据需要，可以进行缩进 或换行4.注释    单行注释：#注释文字    单行注释：-- 注释文字    多行注释：/* 注释文字  */</code></pre></div><h3 id="SQL的语言分类"><a href="#SQL的语言分类" class="headerlink" title="SQL的语言分类"></a>SQL的语言分类</h3><div class="hljs code-wrapper"><pre><code>DQL（Data Query Language）：数据查询语言    select DML(Data Manipulate Language):数据操作语言    insert 、update、deleteDDL（Data Define Languge）：数据定义语言    create、drop、alterTCL（Transaction Control Language）：事务控制语言    commit、rollback</code></pre></div><h3 id="SQL的常见命令"><a href="#SQL的常见命令" class="headerlink" title="SQL的常见命令"></a>SQL的常见命令</h3><div class="hljs code-wrapper"><pre><code>show databases； 查看所有的数据库use 库名； 打开指定 的库show tables ; 显示库中的所有表show tables from 库名;显示指定库中的所有表create table 表名(    字段名 字段类型,        字段名 字段类型); 创建表desc 表名; 查看指定表的结构select * from 表名;显示表中的所有数据</code></pre></div><h2 id="DQL语言的学习"><a href="#DQL语言的学习" class="headerlink" title="DQL语言的学习"></a>DQL语言的学习</h2><h3 id="进阶1：基础查询"><a href="#进阶1：基础查询" class="headerlink" title="进阶1：基础查询"></a>进阶1：基础查询</h3><div class="hljs code-wrapper"><pre><code>语法：SELECT 要查询的东西【FROM 表名】;类似于Java中 :System.out.println(要打印的东西);特点：①通过select查询完的结果 ，是一个虚拟的表格，不是真实存在② 要查询的东西 可以是常量值、可以是表达式、可以是字段、可以是函数</code></pre></div><h3 id="进阶2：条件查询"><a href="#进阶2：条件查询" class="headerlink" title="进阶2：条件查询"></a>进阶2：条件查询</h3><div class="hljs code-wrapper"><pre><code>条件查询：根据条件过滤原始表的数据，查询到想要的数据语法：select     要查询的字段|表达式|常量值|函数from     表where     条件 ;分类：一、条件表达式    示例：salary&gt;10000    条件运算符：    &gt; &lt; &gt;= &lt;= = != &lt;&gt;二、逻辑表达式示例：salary&gt;10000 &amp;&amp; salary&lt;20000逻辑运算符：    and（&amp;&amp;）:两个条件如果同时成立，结果为true，否则为false    or(||)：两个条件只要有一个成立，结果为true，否则为false    not(!)：如果条件成立，则not后为false，否则为true三、模糊查询示例：last_name like &#39;a%&#39;</code></pre></div><h3 id="进阶3：排序查询"><a href="#进阶3：排序查询" class="headerlink" title="进阶3：排序查询"></a>进阶3：排序查询</h3><div class="hljs code-wrapper"><pre><code>语法：select    要查询的东西from    表where     条件order by 排序的字段|表达式|函数|别名 【asc|desc】</code></pre></div><p>​    </p><h3 id="进阶4：常见函数"><a href="#进阶4：常见函数" class="headerlink" title="进阶4：常见函数"></a>进阶4：常见函数</h3><p>​    一、单行函数<br>​    1、字符函数<br>​        concat拼接<br>​        substr截取子串<br>​        upper转换成大写<br>​        lower转换成小写<br>​        trim去前后指定的空格和字符<br>​        ltrim去左边空格<br>​        rtrim去右边空格<br>​        replace替换<br>​        lpad左填充<br>​        rpad右填充<br>​        instr返回子串第一次出现的索引<br>​        length 获取字节个数<br>​        </p><div class="hljs code-wrapper"><pre><code>2、数学函数    round 四舍五入    rand 随机数    floor向下取整    ceil向上取整    mod取余    truncate截断3、日期函数    now当前系统日期+时间    curdate当前系统日期    curtime当前系统时间    str_to_date 将字符转换成日期    date_format将日期转换成字符4、流程控制函数    if 处理双分支    case语句 处理多分支        情况1：处理等值判断        情况2：处理条件判断    5、其他函数    version版本    database当前库    user当前连接用户</code></pre></div><p>​    </p><p>二、分组函数</p><div class="hljs code-wrapper"><pre><code>    sum 求和    max 最大值    min 最小值    avg 平均值    count 计数    特点：    1、以上五个分组函数都忽略null值，除了count(*)    2、sum和avg一般用于处理数值型        max、min、count可以处理任何数据类型    3、都可以搭配distinct使用，用于统计去重后的结果    4、count的参数可以支持：        字段、*、常量值，一般放1       建议使用 count(*)</code></pre></div><h2 id="进阶5：分组查询"><a href="#进阶5：分组查询" class="headerlink" title="进阶5：分组查询"></a>进阶5：分组查询</h2><div class="hljs code-wrapper"><pre><code>语法：select 查询的字段，分组函数from 表group by 分组的字段特点：1、可以按单个字段分组2、和分组函数一同查询的字段最好是分组后的字段3、分组筛选        针对的表    位置            关键字分组前筛选：    原始表        group by的前面        where分组后筛选：    分组后的结果集    group by的后面        having4、可以按多个字段分组，字段之间用逗号隔开5、可以支持排序6、having后可以支持别名</code></pre></div><h2 id="进阶6：多表连接查询"><a href="#进阶6：多表连接查询" class="headerlink" title="进阶6：多表连接查询"></a>进阶6：多表连接查询</h2><div class="hljs code-wrapper"><pre><code>笛卡尔乘积：如果连接条件省略或无效则会出现解决办法：添加上连接条件</code></pre></div><p>一、传统模式下的连接 ：等值连接——非等值连接</p><div class="hljs code-wrapper"><pre><code>1.等值连接的结果 = 多个表的交集2.n表连接，至少需要n-1个连接条件3.多个表不分主次，没有顺序要求4.一般为表起别名，提高阅读性和性能</code></pre></div><p>二、sql99语法：通过join关键字实现连接</p><div class="hljs code-wrapper"><pre><code>含义：1999年推出的sql语法支持：等值连接、非等值连接 （内连接）外连接交叉连接语法：select 字段，...from 表1【inner|left outer|right outer|cross】join 表2 on  连接条件【inner|left outer|right outer|cross】join 表3 on  连接条件【where 筛选条件】【group by 分组字段】【having 分组后的筛选条件】【order by 排序的字段或表达式】好处：语句上，连接条件和筛选条件实现了分离，简洁明了！</code></pre></div><p>​<br>三、自连接</p><p>案例：查询员工名和直接上级的名称</p><p>sql99</p><div class="hljs code-wrapper"><pre><code>SELECT e.last_name,m.last_nameFROM employees eJOIN employees m ON e.`manager_id`=m.`employee_id`;</code></pre></div><p>sql92</p><div class="hljs code-wrapper"><pre><code>SELECT e.last_name,m.last_nameFROM employees e,employees m WHERE e.`manager_id`=m.`employee_id`;</code></pre></div><h2 id="进阶7：子查询"><a href="#进阶7：子查询" class="headerlink" title="进阶7：子查询"></a>进阶7：子查询</h2><p>含义：</p><div class="hljs code-wrapper"><pre><code>一条查询语句中又嵌套了另一条完整的select语句，其中被嵌套的select语句，称为子查询或内查询在外面的查询语句，称为主查询或外查询</code></pre></div><p>特点：</p><div class="hljs code-wrapper"><pre><code>1、子查询都放在小括号内2、子查询可以放在from后面、select后面、where后面、having后面，但一般放在条件的右侧3、子查询优先于主查询执行，主查询使用了子查询的执行结果4、子查询根据查询结果的行数不同分为以下两类：① 单行子查询    结果集只有一行    一般搭配单行操作符使用：&gt; &lt; = &lt;&gt; &gt;= &lt;=     非法使用子查询的情况：    a、子查询的结果为一组值    b、子查询的结果为空    ② 多行子查询    结果集有多行    一般搭配多行操作符使用：any、all、in、not in    in： 属于子查询结果中的任意一个就行    any和all往往可以用其他查询代替</code></pre></div><h2 id="进阶8：分页查询"><a href="#进阶8：分页查询" class="headerlink" title="进阶8：分页查询"></a>进阶8：分页查询</h2><p>应用场景：</p><div class="hljs code-wrapper"><pre><code>实际的web项目中需要根据用户的需求提交对应的分页查询的sql语句</code></pre></div><p>语法：</p><div class="hljs code-wrapper"><pre><code>select 字段|表达式,...from 表【where 条件】【group by 分组字段】【having 条件】【order by 排序的字段】limit 【起始的条目索引，】条目数;</code></pre></div><p>特点：</p><div class="hljs code-wrapper"><pre><code>1.起始条目索引从0开始2.limit子句放在查询语句的最后3.公式：select * from  表 limit （page-1）*sizePerPage,sizePerPage假如:每页显示条目数sizePerPage要显示的页数 page</code></pre></div><h2 id="进阶9：联合查询"><a href="#进阶9：联合查询" class="headerlink" title="进阶9：联合查询"></a>进阶9：联合查询</h2><p>引入：<br>    union 联合、合并</p><p>语法：</p><div class="hljs code-wrapper"><pre><code>select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】select 字段|常量|表达式|函数 【from 表】 【where 条件】 union  【all】.....select 字段|常量|表达式|函数 【from 表】 【where 条件】</code></pre></div><p>特点：</p><div class="hljs code-wrapper"><pre><code>1、多条查询语句的查询的列数必须是一致的2、多条查询语句的查询的列的类型几乎相同3、union代表去重，union all代表不去重</code></pre></div><h2 id="DML语言"><a href="#DML语言" class="headerlink" title="DML语言"></a>DML语言</h2><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>语法：<br>    insert into 表名(字段名，…)<br>    values(值1，…);</p><p>特点：</p><div class="hljs code-wrapper"><pre><code>1、字段类型和值类型一致或兼容，而且一一对应2、可以为空的字段，可以不用插入值，或用null填充3、不可以为空的字段，必须插入值4、字段个数和值的个数必须一致5、字段可以省略，但默认所有字段，并且顺序和表中的存储顺序一致</code></pre></div><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><p>修改单表语法：</p><div class="hljs code-wrapper"><pre><code>update 表名 set 字段=新值,字段=新值【where 条件】</code></pre></div><p>修改多表语法：</p><div class="hljs code-wrapper"><pre><code>update 表1 别名1,表2 别名2set 字段=新值，字段=新值where 连接条件and 筛选条件</code></pre></div><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>方式1：delete语句 </p><p>单表的删除： ★<br>    delete from 表名 【where 筛选条件】</p><p>多表的删除：<br>    delete 别名1，别名2<br>    from 表1 别名1，表2 别名2<br>    where 连接条件<br>    and 筛选条件;</p><p>方式2：truncate语句</p><div class="hljs code-wrapper"><pre><code>truncate table 表名</code></pre></div><p>两种方式的区别【面试题】</p><div class="hljs code-wrapper"><pre><code>#1.truncate不能加where条件，而delete可以加where条件#2.truncate的效率高一丢丢#3.truncate 删除带自增长的列的表后，如果再插入数据，数据从1开始#delete 删除带自增长列的表后，如果再插入数据，数据从上一次的断点处开始#4.truncate删除不能回滚，delete删除可以回滚</code></pre></div><h2 id="DDL语句"><a href="#DDL语句" class="headerlink" title="DDL语句"></a>DDL语句</h2><h3 id="库和表的管理"><a href="#库和表的管理" class="headerlink" title="库和表的管理"></a>库和表的管理</h3><p>库的管理：</p><div class="hljs code-wrapper"><pre><code>一、创建库create database 库名二、删除库drop database 库名</code></pre></div><p>表的管理：<br>    #1.创建表</p><div class="hljs code-wrapper"><pre><code>CREATE TABLE IF NOT EXISTS stuinfo(    stuId INT,    stuName VARCHAR(20),    gender CHAR,    bornDate DATETIME</code></pre></div><p>​    </p><div class="hljs code-wrapper"><pre><code>);DESC studentinfo;#2.修改表 alter语法：ALTER TABLE 表名 ADD|MODIFY|DROP|CHANGE COLUMN 字段名 【字段类型】;#①修改字段名ALTER TABLE studentinfo CHANGE  COLUMN sex gender CHAR;#②修改表名ALTER TABLE stuinfo RENAME [TO]  studentinfo;#③修改字段类型和列级约束ALTER TABLE studentinfo MODIFY COLUMN borndate DATE ;#④添加字段ALTER TABLE studentinfo ADD COLUMN email VARCHAR(20) first;#⑤删除字段ALTER TABLE studentinfo DROP COLUMN email;</code></pre></div><p>​    </p><div class="hljs code-wrapper"><pre><code>#3.删除表DROP TABLE [IF EXISTS] studentinfo;</code></pre></div><p>​    </p><h3 id="常见类型"><a href="#常见类型" class="headerlink" title="常见类型"></a>常见类型</h3><div class="hljs code-wrapper"><pre><code>整型：    小数：    浮点型    定点型字符型：日期型：Blob类型：</code></pre></div><h3 id="常见约束"><a href="#常见约束" class="headerlink" title="常见约束"></a>常见约束</h3><div class="hljs code-wrapper"><pre><code>NOT NULLDEFAULTUNIQUECHECKPRIMARY KEYFOREIGN KEY</code></pre></div><h2 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h2><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><div class="hljs code-wrapper"><pre><code>通过一组逻辑操作单元（一组DML——sql语句），将数据从一种状态切换到另外一种状态</code></pre></div><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><div class="hljs code-wrapper"><pre><code>（ACID）原子性：要么都执行，要么都回滚一致性：保证数据的状态操作前和操作后保持一致隔离性：多个事务同时操作相同数据库的同一个数据时，一个事务的执行不受另外一个事务的干扰持久性：一个事务一旦提交，则数据将持久化到本地，除非其他事务对其进行修改</code></pre></div><p>相关步骤：</p><div class="hljs code-wrapper"><pre><code>1、开启事务2、编写事务的一组逻辑操作单元（多条sql语句）3、提交事务或回滚事务</code></pre></div><h3 id="事务的分类："><a href="#事务的分类：" class="headerlink" title="事务的分类："></a>事务的分类：</h3><p>隐式事务，没有明显的开启和结束事务的标志</p><div class="hljs code-wrapper"><pre><code>比如insert、update、delete语句本身就是一个事务</code></pre></div><p>显式事务，具有明显的开启和结束事务的标志</p><div class="hljs code-wrapper"><pre><code>    1、开启事务    取消自动提交事务的功能        2、编写事务的一组逻辑操作单元（多条sql语句）    insert    update    delete        3、提交事务或回滚事务</code></pre></div><h3 id="使用到的关键字"><a href="#使用到的关键字" class="headerlink" title="使用到的关键字"></a>使用到的关键字</h3><div class="hljs code-wrapper"><pre><code>set autocommit=0;start transaction;commit;rollback;savepoint  断点commit to 断点rollback to 断点</code></pre></div><h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别:"></a>事务的隔离级别:</h3><p>事务并发问题如何发生？</p><div class="hljs code-wrapper"><pre><code>当多个事务同时操作同一个数据库的相同数据时</code></pre></div><p>事务的并发问题有哪些？</p><div class="hljs code-wrapper"><pre><code>脏读：一个事务读取到了另外一个事务未提交的数据不可重复读：同一个事务中，多次读取到的数据不一致幻读：一个事务读取数据时，另外一个事务进行更新，导致第一个事务读取到了没有更新的数据</code></pre></div><p>如何避免事务的并发问题？</p><div class="hljs code-wrapper"><pre><code>通过设置事务的隔离级别1、READ UNCOMMITTED2、READ COMMITTED 可以避免脏读3、REPEATABLE READ 可以避免脏读、不可重复读和一部分幻读4、SERIALIZABLE可以避免脏读、不可重复读和幻读</code></pre></div><p>设置隔离级别：</p><div class="hljs code-wrapper"><pre><code>set session|global  transaction isolation level 隔离级别名;</code></pre></div><p>查看隔离级别：</p><div class="hljs code-wrapper"><pre><code>select @@tx_isolation;</code></pre></div><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>含义：理解成一张虚拟的表</p><p>视图和表的区别：</p><div class="hljs code-wrapper"><pre><code>    使用方式    占用物理空间视图    完全相同    不占用，仅仅保存的是sql逻辑表    完全相同    占用</code></pre></div><p>视图的好处：</p><div class="hljs code-wrapper"><pre><code>1、sql语句提高重用性，效率高2、和表实现了分离，提高了安全性</code></pre></div><h3 id="视图的创建"><a href="#视图的创建" class="headerlink" title="视图的创建"></a>视图的创建</h3><div class="hljs code-wrapper"><pre><code>语法：CREATE VIEW  视图名AS查询语句;</code></pre></div><h3 id="视图的增删改查"><a href="#视图的增删改查" class="headerlink" title="视图的增删改查"></a>视图的增删改查</h3><div class="hljs code-wrapper"><pre><code>1、查看视图的数据 ★SELECT * FROM my_v4;SELECT * FROM my_v1 WHERE last_name=&#39;Partners&#39;;2、插入视图的数据INSERT INTO my_v4(last_name,department_id) VALUES(&#39;虚竹&#39;,90);3、修改视图的数据UPDATE my_v4 SET last_name =&#39;梦姑&#39; WHERE last_name=&#39;虚竹&#39;;</code></pre></div><p>​    </p><div class="hljs code-wrapper"><pre><code>4、删除视图的数据DELETE FROM my_v4;</code></pre></div><h3 id="某些视图不能更新"><a href="#某些视图不能更新" class="headerlink" title="某些视图不能更新"></a>某些视图不能更新</h3><div class="hljs code-wrapper"><pre><code>包含以下关键字的sql语句：分组函数、distinct、group  by、having、union或者union all常量视图Select中包含子查询joinfrom一个不能更新的视图where子句的子查询引用了from子句中的表</code></pre></div><h3 id="视图逻辑的更新"><a href="#视图逻辑的更新" class="headerlink" title="视图逻辑的更新"></a>视图逻辑的更新</h3><div class="hljs code-wrapper"><pre><code>#方式一：CREATE OR REPLACE VIEW test_v7ASSELECT last_name FROM employeesWHERE employee_id&gt;100;#方式二:ALTER VIEW test_v7ASSELECT employee_id FROM employees;SELECT * FROM test_v7;</code></pre></div><h3 id="视图的删除"><a href="#视图的删除" class="headerlink" title="视图的删除"></a>视图的删除</h3><div class="hljs code-wrapper"><pre><code>DROP VIEW test_v1,test_v2,test_v3;</code></pre></div><h3 id="视图结构的查看"><a href="#视图结构的查看" class="headerlink" title="视图结构的查看"></a>视图结构的查看</h3><div class="hljs code-wrapper"><pre><code>DESC test_v7;SHOW CREATE VIEW test_v7;</code></pre></div><h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><p>含义：一组经过预先编译的sql语句的集合<br>好处：</p><div class="hljs code-wrapper"><pre><code>1、提高了sql语句的重用性，减少了开发程序员的压力2、提高了效率3、减少了传输次数</code></pre></div><p>分类：</p><div class="hljs code-wrapper"><pre><code>1、无返回无参2、仅仅带in类型，无返回有参3、仅仅带out类型，有返回无参4、既带in又带out，有返回有参5、带inout，有返回有参注意：in、out、inout都可以在一个存储过程中带多个</code></pre></div><h3 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h3><p>语法：</p><div class="hljs code-wrapper"><pre><code>create procedure 存储过程名(in|out|inout 参数名  参数类型,...)begin    存储过程体end</code></pre></div><p>类似于方法：</p><div class="hljs code-wrapper"><pre><code>修饰符 返回类型 方法名(参数类型 参数名,...)&#123;    方法体;&#125;</code></pre></div><p>注意</p><div class="hljs code-wrapper"><pre><code>1、需要设置新的结束标记delimiter 新的结束标记示例：delimiter $CREATE PROCEDURE 存储过程名(IN|OUT|INOUT 参数名  参数类型,...)BEGIN    sql语句1;    sql语句2;END $2、存储过程体中可以有多条sql语句，如果仅仅一条sql语句，则可以省略begin end3、参数前面的符号的意思in:该参数只能作为输入 （该参数不能做返回值）out：该参数只能作为输出（该参数只能做返回值）inout：既能做输入又能做输出</code></pre></div><h1 id="调用存储过程"><a href="#调用存储过程" class="headerlink" title="调用存储过程"></a>调用存储过程</h1><div class="hljs code-wrapper"><pre><code>call 存储过程名(实参列表)</code></pre></div><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="创建函数"><a href="#创建函数" class="headerlink" title="创建函数"></a>创建函数</h3><p>学过的函数：LENGTH、SUBSTR、CONCAT等<br>语法：</p><div class="hljs code-wrapper"><pre><code>CREATE FUNCTION 函数名(参数名 参数类型,...) RETURNS 返回类型BEGIN    函数体END</code></pre></div><h3 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h3><div class="hljs code-wrapper"><pre><code>SELECT 函数名（实参列表）</code></pre></div><h3 id="函数和存储过程的区别"><a href="#函数和存储过程的区别" class="headerlink" title="函数和存储过程的区别"></a>函数和存储过程的区别</h3><div class="hljs code-wrapper"><pre><code>        关键字        调用语法    返回值            应用场景函数        FUNCTION    SELECT 函数()    只能是一个        一般用于查询结果为一个值并返回时，当有返回值而且仅仅一个存储过程    PROCEDURE    CALL 存储过程()    可以有0个或多个        一般用于更新</code></pre></div><h2 id="流程控制结构"><a href="#流程控制结构" class="headerlink" title="流程控制结构"></a>流程控制结构</h2><h3 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h3><p>一、全局变量</p><p>作用域：针对于所有会话（连接）有效，但不能跨重启</p><div class="hljs code-wrapper"><pre><code>查看所有全局变量SHOW GLOBAL VARIABLES;查看满足条件的部分系统变量SHOW GLOBAL VARIABLES LIKE &#39;%char%&#39;;查看指定的系统变量的值SELECT @@global.autocommit;为某个系统变量赋值SET @@global.autocommit=0;SET GLOBAL autocommit=0;</code></pre></div><p>二、会话变量</p><p>作用域：针对于当前会话（连接）有效</p><div class="hljs code-wrapper"><pre><code>查看所有会话变量SHOW SESSION VARIABLES;查看满足条件的部分会话变量SHOW SESSION VARIABLES LIKE &#39;%char%&#39;;查看指定的会话变量的值SELECT @@autocommit;SELECT @@session.tx_isolation;为某个会话变量赋值SET @@session.tx_isolation=&#39;read-uncommitted&#39;;SET SESSION tx_isolation=&#39;read-committed&#39;;</code></pre></div><h3 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h3><p>一、用户变量</p><p>声明并初始化：</p><div class="hljs code-wrapper"><pre><code>SET @变量名=值;SET @变量名:=值;SELECT @变量名:=值;</code></pre></div><p>赋值：</p><div class="hljs code-wrapper"><pre><code>方式一：一般用于赋简单的值SET 变量名=值;SET 变量名:=值;SELECT 变量名:=值;方式二：一般用于赋表 中的字段值SELECT 字段名或表达式 INTO 变量FROM 表;</code></pre></div><p>使用：</p><div class="hljs code-wrapper"><pre><code>select @变量名;</code></pre></div><p>二、局部变量</p><p>声明：</p><div class="hljs code-wrapper"><pre><code>declare 变量名 类型 【default 值】;</code></pre></div><p>赋值：</p><div class="hljs code-wrapper"><pre><code>方式一：一般用于赋简单的值SET 变量名=值;SET 变量名:=值;SELECT 变量名:=值;方式二：一般用于赋表 中的字段值SELECT 字段名或表达式 INTO 变量FROM 表;</code></pre></div><p>使用：</p><div class="hljs code-wrapper"><pre><code>select 变量名</code></pre></div><p>二者的区别：</p><div class="hljs code-wrapper"><pre><code>        作用域            定义位置        语法</code></pre></div><p>用户变量    当前会话        会话的任何地方        加@符号，不用指定类型<br>局部变量    定义它的BEGIN END中     BEGIN END的第一句话    一般不用加@,需要指定类型</p><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>一、if函数<br>    语法：if(条件，值1，值2)<br>    特点：可以用在任何位置</p><p>二、case语句</p><p>语法：</p><div class="hljs code-wrapper"><pre><code>情况一：类似于switchcase 表达式when 值1 then 结果1或语句1(如果是语句，需要加分号) when 值2 then 结果2或语句2(如果是语句，需要加分号)...else 结果n或语句n(如果是语句，需要加分号)end 【case】（如果是放在begin end中需要加上case，如果放在select后面不需要）情况二：类似于多重ifcase when 条件1 then 结果1或语句1(如果是语句，需要加分号) when 条件2 then 结果2或语句2(如果是语句，需要加分号)...else 结果n或语句n(如果是语句，需要加分号)end 【case】（如果是放在begin end中需要加上case，如果放在select后面不需要）</code></pre></div><p>特点：<br>    可以用在任何位置</p><p>三、if elseif语句</p><p>语法：</p><div class="hljs code-wrapper"><pre><code>if 情况1 then 语句1;elseif 情况2 then 语句2;...else 语句n;end if;</code></pre></div><p>特点：<br>    只能用在begin end中！！！！！！！！！！！！！！！</p><p>三者比较：<br>            应用场合<br>    if函数        简单双分支<br>    case结构    等值判断 的多分支<br>    if结构        区间判断 的多分支</p><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>语法：</p><div class="hljs code-wrapper"><pre><code>【标签：】WHILE 循环条件  DO    循环体END WHILE 【标签】;</code></pre></div><p>特点：</p><div class="hljs code-wrapper"><pre><code>只能放在BEGIN END里面如果要搭配leave跳转语句，需要使用标签，否则可以不用标签leave类似于java中的break语句，跳出所在循环！！！</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>mysql基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xilou</title>
    <link href="/2021/03/30/%E5%88%98%E8%8A%B3/"/>
    <url>/2021/03/30/%E5%88%98%E8%8A%B3/</url>
    
    <content type="html"><![CDATA[<h1 id="刘芳"><a href="#刘芳" class="headerlink" title="刘芳"></a>刘芳</h1><h2 id="求职意向"><a href="#求职意向" class="headerlink" title="求职意向"></a>求职意向</h2><p>=========</p><ul><li>Java开发工程师</li></ul><hr><h2 id="个人信息"><a href="#个人信息" class="headerlink" title="个人信息"></a>个人信息</h2><p>=========</p><ul><li>性 别：男                     年 龄：24</li><li>手 机：14779732375            邮 箱：<a href="mailto:&#x36;&#x37;&#x31;&#53;&#54;&#x32;&#x31;&#x36;&#48;&#64;&#113;&#113;&#x2e;&#99;&#111;&#109;">&#x36;&#x37;&#x31;&#53;&#54;&#x32;&#x31;&#x36;&#48;&#64;&#113;&#113;&#x2e;&#99;&#111;&#109;</a></li><li>专 业：计算机科学与技术       个人博客：<a href="https://xilou37.github.io/">https://xilou37.github.io/</a></li></ul><hr><h2 id="教育经历"><a href="#教育经历" class="headerlink" title="教育经历"></a>教育经历</h2><p>=========</p><ul><li>燕京理工学院     2017.9~2021.7     本科</li></ul><hr><h2 id="专业技能"><a href="#专业技能" class="headerlink" title="专业技能"></a>专业技能</h2><p>=========</p><ul><li>掌握Java基础知识，具备良好的编程习惯以及代码规范</li><li>熟练使用MySQL数据库，会编写基本的SQL语句</li><li>熟练使用Linux系统常用命令 </li><li>了解运用常见的Java开发框架：SpringMVC,MyBatis,SpringBoot</li><li>熟悉使用eclipse、idea等开发工具</li><li>其它<ul><li>英语过四级，可以更轻松的阅读技术文档</li><li>计算机过二级，熟练使用office软件<h2 id="项目经历"><a href="#项目经历" class="headerlink" title="项目经历"></a>项目经历</h2>=========</li></ul></li><li><strong>项目一 : 网上书城</strong><ul><li><blockquote><p><strong>项目描述</strong>:  Javaweb项目，主要实现了用户的登入注册模块、购物车模块、订单模块、图书管理模块。</p></blockquote></li><li><blockquote><p><strong>技术描述：</strong></p></blockquote><ul><li>jQuery，XML&amp;Tomcat，Servlet，jsp，EL表达式&amp;JSTL标签库，cookie和session，Filter过滤器，JSON和Ajax请求&amp;i18n国际化。</li></ul></li></ul></li><li><strong>项目二 : 客户管理系统</strong><ul><li><blockquote><p><strong>项目描述</strong>:  该客户管理系统是一个Javaweb项目，主要实现了对客户信息的CRUD操作。</p></blockquote></li><li><blockquote><p><strong>技术描述：</strong></p></blockquote><ol><li>基础框架：ssm(SpringMVC+Spring+MyBatis)</li><li>数据库：MySQL</li><li>前端框架：bootstrap快速搭建简洁美观的界面</li><li>项目的依赖管理：Maven</li><li>分页：pageHelper</li><li>逆向工程：MyBatis Generator</li></ol></li></ul></li></ul><h2 id="自我评价"><a href="#自我评价" class="headerlink" title="自我评价"></a>自我评价</h2><p>=========</p><ul><li>喜欢编程开发</li><li>善于积累学到的知识</li><li>做事认真，待人诚恳</li><li>谢谢您阅读我的简历</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>简历</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java面向对象</title>
    <link href="/2021/03/25/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <url>/2021/03/25/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="java面向对象"><a href="#java面向对象" class="headerlink" title="java面向对象"></a>java面向对象</h2><h3 id="对象数组的内存解析"><a href="#对象数组的内存解析" class="headerlink" title="对象数组的内存解析"></a>对象数组的内存解析</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Student[] stus = <span class="hljs-keyword">new</span> Student[<span class="hljs-number">5</span>];<br>stus[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> Student();<br><span class="hljs-comment">//下面是类结构</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>&#123;<br>    <span class="hljs-keyword">int</span> number;<br>    <span class="hljs-keyword">int</span> state;<br>    <span class="hljs-keyword">int</span> score;<br>&#125; <br></code></pre></div></td></tr></table></figure><ul><li>当执行第一行代码时，计算机会在内存进行如下操作：</li></ul><ol><li>在堆中开辟一块拥有首地址的内存块，容量单位为5</li><li>在栈中存入刚才开辟的首地址</li></ol><ul><li>当执行第二行代码时，计算机会在内存进行如下操作：</li></ul><ol><li>在堆中创建存放学生类数据的区域</li><li>在该区域的首地址存入上一行代码创建的内存块中第一个位置</li></ol><ul><li><strong><em>内存解析的说明</em></strong>  </li></ul><ol><li>引用类型的变量，只可能存储两类值：null 或 地址值（含变量的类型）</li></ol><hr><h3 id="匿名对象的使用"><a href="#匿名对象的使用" class="headerlink" title="匿名对象的使用"></a>匿名对象的使用</h3><ul><li>理解： 我们创建的对象，没有显示的赋给一个变量名，即为匿名对象</li><li>特征：匿名对象只能调用一次</li><li>使用：如下<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InstanceTest</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        PhoneMall mall = <span class="hljs-keyword">new</span> PhoneMall();<br>        mall.show(<span class="hljs-keyword">new</span> Phone());<span class="hljs-comment">//此处是匿名对象的使用，在传参的时候进行赋值</span><br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PhoneMall</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(Phone phone)</span></span>&#123;<br>        phone.sentMail();<br>        phone.playGame();<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Phone</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sentMail</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;手机可以发送短信&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span>  <span class="hljs-title">playGame</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;手机可以玩游戏&quot;</span>);<br>    &#125; <br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><hr><h3 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h3><ul><li>定义：在同一个类中，允许存在一个以上的同名方法，只要他们的参数个数和参数类型不同即可</li><li>判断是否是重载：跟方法的权限修饰符、返回值类型、形参变量名、方法体都没有关系</li></ul><hr><h3 id="可变形参"><a href="#可变形参" class="headerlink" title="可变形参"></a>可变形参</h3><ul><li>格式：(String … str)<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(String ... strs)</span></span>&#123;&#125;<span class="hljs-comment">//形参个数没有指定，按需求传入，因此是可变的；</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(String[] strs)</span></span>&#123;&#125;<span class="hljs-comment">//效果和上面的方法是一样的，一个可变数组去存可变的形参 </span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i;String ... strs)</span></span>&#123;&#125;<span class="hljs-comment">//可变形参位置必须放到其他类型的形参后面</span><br></code></pre></div></td></tr></table></figure></li></ul><hr><h3 id="变量的赋值"><a href="#变量的赋值" class="headerlink" title="变量的赋值"></a>变量的赋值</h3><ul><li><p>如果变量是基本数据类型，此时赋值的是变量所存的具体数据值</p></li><li><p>如果变量是引用数据类型，此时赋值的是变量所报存数据的地址值<br>方法的形参传递机制：值传递</p></li><li><p>形参：方法定义时，声明在小括号内的参数实参：方法调用时，实际传递给形参的数据</p></li><li><p>值传递机制：</p><ul><li>如果参数是基本数据类型，此时实参传给形参的是实参真是储存的数据值</li><li>如果参数是应用数据类型，此时实参传给形参的是实参存储数的地址值</li></ul></li></ul><hr><h3 id="封装性的体现"><a href="#封装性的体现" class="headerlink" title="封装性的体现"></a>封装性的体现</h3><ul><li>我们将某个类的属性私有化（Private），然后提供公共的（Public）set 和 get 方法去获取或则修改类的属性</li><li>封装性的体现，需要权限修饰符来体现：</li></ul><ol><li>Java规定的4中权限（从小到大排列）：private,缺省，protected，public</li><li>4种全限修饰符可以用来修饰类及类的内部结构：属性、方法、构造器、内部类</li><li>具体的：4种权限都可以用来修饰类的内部结构：属性、方法、构造器、内部类</li><li>修饰类的话，只能用：缺省和public</li></ol><ul><li>4种权限修饰符的权限</li></ul><table><thead><tr><th align="center">修饰符</th><th align="center">类内部</th><th align="center">同一个包</th><th align="center">不同包的子类</th><th align="center">同一个工程</th></tr></thead><tbody><tr><td align="center">private</td><td align="center">yes</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">(缺省)</td><td align="center">yes</td><td align="center">yes</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">protected</td><td align="center">yes</td><td align="center">yes</td><td align="center">yes</td><td align="center"></td></tr><tr><td align="center">public</td><td align="center">yes</td><td align="center">yes</td><td align="center">yes</td><td align="center">yes</td></tr></tbody></table><hr><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><ol><li>功能：<br>• 构造对象<br>• 给属性初始化值</li><li>说明：<br>• 如果自己没写构造器的话，系统默认有一个空参构造器<br>• 构造器的格式：权限修饰符    类名    （形参列表）{    }<br>• 一个类中若有多个构造器，彼此之间构成重载<br>• 一旦我们自己定义了类的构造器之后，系统就不再提供默认的空参构造器了<br>• 一个类中，至少会有一个构造器</li><li>总结：属性赋值的先后顺序</li></ol><hr><h3 id="属性赋值的种类"><a href="#属性赋值的种类" class="headerlink" title="属性赋值的种类"></a>属性赋值的种类</h3><ol><li>默认初始化</li><li>显示初始化</li><li>构造器中初始化</li><li>通过”对象 . 方法” 或 “对象 . 属性”的方式，赋值<br>赋值后的先后顺序为：1-&gt;2-&gt;3-&gt;4</li></ol><hr><h3 id="this关键字的使用"><a href="#this关键字的使用" class="headerlink" title="this关键字的使用"></a>this关键字的使用</h3><ol><li>this 可以用来修饰、调用：属性、方法、构造器</li><li>当this修饰属性和方法时：this应理解为：当前对象 或 当正在创建的对象</li></ol><ul><li>一般情况下：<br>无论是在类的方法中还是在类的构造器中，我们都可以使用“this . 属性”或“this . 方法”的方式，调用对象的属性和方法，但我们可以选择省略“this .”</li><li>特殊情况下：<br>当方法的形参或者构造器的形参和类的属性名同名时，我们必须显示的使用 “this .变量”，表明此变量是属性，而非形参</li><li>注意：当this调用构造器时</li></ul><ol><li>我们在类的构造器中，可以显示的使用“this（形参列表）”的方式，调用本类中指定的其他构造器</li><li>构造器中不能通过“this（形参列表）”方式调用自己</li><li>如果一个类中有n个构造器，则最多只能有n-1个构造器中调用了“this（形参列表）”</li><li>规定：“this（形参列表）”必须声明在当前构造器的首行</li><li>构造器内部，最多只能声明一个“this（形参列表）”，用来调用其他构造器</li></ol><hr><h3 id="super关键字的使用"><a href="#super关键字的使用" class="headerlink" title="super关键字的使用"></a>super关键字的使用</h3><ul><li>super理解为：父类的…</li><li>supper可以用来调用：属性、方法、构造器</li><li>super的使用：<ul><li>调用属性和方法<ul><li>我们可以再子类的方法或者构造器中，通过使用“super.属性”或者“super.方法”的方式，显示的调用父类中声明的属性或方法。但是一般省略“super”。</li><li>特殊的：当子类和父类定义了重名的属性时，我们想要在子类中调用父类中声明的属性，则必须显示的使用“super.属性”的方式，表明调用父类中声明的属性。当子类重写了父类的方法以后，我们想要在子类的方法中调用父类中被重写的方法时，则必须显示的使用“super.方法”的方式，表明调用的是父类中被重写的方法。</li></ul></li><li>调用构造器<ul><li>我们可以在子类的构造器中显示的使用“super（形参列表）”的方式，调用父类中声明的指定的构造器。</li><li>“super（形参列表）”的使用，必须声明在子类构造器的首行。</li><li>我们在类的构造器中，针对于“this（形参列表）”或“super（形参列表）”只能二选一，不能同时出现。</li><li>在构造器的首行，若没有显示的调用“this（形参列表）”或者“super（形参列表）”则默认调用的是父类中空参的构造器：super（）。</li><li>在类的多个构造器中，至少有一个类的构造器使用了“super（形参列表）”调用父类中的构造器</li></ul></li></ul></li></ul><hr><h3 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h3><ul><li>好处：<ol><li>减少了代码的冗余，提高代码的复用性</li><li>便于功能的扩展</li><li>为之后多态性的使用提供前提</li></ol></li><li>体现：<ol><li>一旦子类A继承了父类B以后，子类A中获取了父类B中声明的所有属性和方法，同样包含父类中声明private的属性和方法，只是因为封装性的影响，使得子类不能直接调用父类的结构而已。</li><li>子类继承父类之后，还可以声明自己特有的属性和方法，实现功能的扩展。</li><li>关键字：extends：延展，扩展</li></ol></li><li>java关于继承的规定<ol><li>一个类可以被多个子类继承</li><li>一个类只能有一个父类：叫类的单继承性</li><li>子父类是相对的概念：有多层继承的概念</li></ol></li></ul><hr><h3 id="子类对象实例化的全过程"><a href="#子类对象实例化的全过程" class="headerlink" title="子类对象实例化的全过程"></a>子类对象实例化的全过程</h3><ol><li>从结果上来看（继承性）<ul><li>子类继承父类后，就获取了父类中声明的属性和方法，创建子类的对象，在堆空间中，就会加载所有的父类中的声明的属性</li></ul></li><li>从过程上来看<ul><li>当我们通过子类的构造器创建子类对象是，我们一定会直接或间接的调用器父类的构造器，进而调用父类的父类的构造器…直到调用了java.lang.Object类中空参的构造器为止。正因为加载过所有的父类的结构，所以才可以看到内存中有父类中的结构，子类对象可以考虑进行调用。</li></ul></li><li>明确：虽然创建子类对象时，调用了父类的构造器，但是自始至终就创建过一个对象，即为new的子类对象。</li></ol><hr><h3 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h3><ol><li>理解：可以理解为一个事物的多种形态。</li><li>何为多态性：父类的引用指向子类的对象。例如下列代码：<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//父类person有两个子类man和woman</span><br>Person p1 = <span class="hljs-keyword">new</span> man();<br>Person p2 = <span class="hljs-keyword">new</span> woman();<br></code></pre></div></td></tr></table></figure></li><li>多态的使用有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际执行的是子类重写的父类的方法。总结：编译，看左边；运行，看右边</li><li>多态性的使用前提：<ul><li>类的继承关系</li><li>方法的重写</li></ul></li><li>注意：<ul><li>对象的多态之适用于方法，不适用于属性；对于属性而言，在编译期和运行期都看父类声明的属性。</li><li>多态性是运行时行为，不是编译时行为</li><li>重载不是多态，重写是多态</li></ul></li></ol><hr><h3 id="方法的重写"><a href="#方法的重写" class="headerlink" title="方法的重写"></a>方法的重写</h3><ol><li>判断两个函数是否为同一个函数：只需确定函数名与参数列表是否都一样</li><li>定义：子类对父类的某一方法进行重新改写。</li><li>注意：<ul><li>当子类对象调用该方法时，则调用的是自己重写的那个方法体；父类对象调用该方法时，则调用的是自己原来的那个方法体</li><li>子类重写的方法的权限修饰符范围不小于父类被重写的方法的权限修饰符</li><li>子类不能重写父类中声明为private权限的方法</li><li>子类重写的方法的返回值类型最好和父类保持一致</li><li>子类和父类中的同名同参的方法要么都声明为非static（这种情况才可以考虑重写），要么都声明为static的（这种情况肯定不是重写）</li></ul></li></ol><hr><h3 id="instanceof关键字："><a href="#instanceof关键字：" class="headerlink" title="instanceof关键字："></a>instanceof关键字：</h3><ol><li>使用：a instanceof A :表示对象a是否是类A的实例，如果是返回true，如果不是，返回false。若在类型强转前不先使用关键字判断一下，很有可能会出现类型转换异常。   </li></ol><hr><h3 id="equals和-的区别"><a href="#equals和-的区别" class="headerlink" title="equals和==的区别"></a>equals和==的区别</h3><ol><li>equals是一个方法，==是运算符</li><li>==可以使用在基本的数据类型变量和引用数据变量中，如果比较的是基本数据类型变量，则表示在比较两个变量保存的数据是否相等（相比较的两个变量的类型不一定要相同）；如果比较的是引用数据类型变量，则表示在比较两个对象的地址是否相同。而equals只能用于引用数据类型的变量，Object中定义的equals（）和==的作用是相同的，比较的是两个对象的地址值是否相同。</li></ol><ul><li>注意点：<ul><li>==运算符两边的数据类型要一致</li><li>像String、Date、File、包装类等都重写了Object类中的equals（）方法，重写之后，比较的不是两个引用的地址是否相同，而是比较两个对象的实体内容是否相同。</li><li>通常情况下，我们自定义的类如果使用equals的话，也通常是比较两个对象的“实体内容”是否相同，那么，我们就需要对Object类中的equals（）方法进行重写。</li><li>手写的equals（）重写实例：<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span></span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == obj)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> Customer)&#123;<br>    Customer cust = (Customer)obj;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.age == cust.age &amp;&amp; <span class="hljs-keyword">this</span>.name.equals(cust.name);<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>在实际的开发中，自动生成equals即可；</li></ul></li></ul><h3 id="Object类中的toString（）的使用"><a href="#Object类中的toString（）的使用" class="headerlink" title="Object类中的toString（）的使用"></a>Object类中的toString（）的使用</h3><ul><li>当我们输出一个对象的引用时，实际上是调用当前对象的toString（）</li><li>Object类中toString（）的定义<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">return</span> getClass().getName()+<span class="hljs-string">&quot;@&quot;</span>+Integer.toHex+String(hashcode());<br>&#125; <br></code></pre></div></td></tr></table></figure></li><li>像String、Date、File、包装类等都重写了Object类中的toString（）方法</li><li>自定义类也可以重写toString（）方法，当调用此方法时，返回对象实体内容，一般情况下则自动生成toString（）</li></ul><hr><h3 id="基本数据类型、包装类与String三者之间如何转换"><a href="#基本数据类型、包装类与String三者之间如何转换" class="headerlink" title="基本数据类型、包装类与String三者之间如何转换"></a>基本数据类型、包装类与String三者之间如何转换</h3><ol><li>基本数据类型—&gt;包装类（自动装箱）</li><li>包装类—&gt;基本数据类型（自动拆箱）<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Integer i = <span class="hljs-number">10</span>;<span class="hljs-comment">//自动装箱</span><br><span class="hljs-keyword">int</span> j = i;<span class="hljs-comment">//自动拆箱</span><br></code></pre></div></td></tr></table></figure></li><li>基本数据类型、包装类—&gt;String<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">int</span> num1 = <span class="hljs-number">10</span>;<br>  <span class="hljs-comment">//方式一：连接运算</span><br>  String str1 = num + <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-comment">//方式二：调用String的valueOf（Xxx xxx）</span><br>  <span class="hljs-keyword">float</span> f1 = <span class="hljs-number">12.3f</span>;<br>  String  str2 =  String.valueOf(f1);<span class="hljs-comment">//&quot;12.3&quot;</span><br>  Double  d1 = <span class="hljs-keyword">new</span> Double(<span class="hljs-number">12.4</span>);<br>  String str3 = String.valueOf(d1);<span class="hljs-comment">//&quot;12.4&quot;</span><br><br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>String类型—&gt;基本数据类型、包装类<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test5</span><span class="hljs-params">()</span></span>&#123;<br>  String str1 = <span class="hljs-string">&quot;123&quot;</span>;<br>  <span class="hljs-keyword">int</span> num2 = Integer.parseInt(str1);<span class="hljs-comment">//123</span><br>  String str2 = <span class="hljs-string">&quot;true&quot;</span>;<br>  <span class="hljs-keyword">boolean</span> b1 = Boolean.parseBoolean(str2);<span class="hljs-comment">//true</span><br>  String str3 = <span class="hljs-string">&quot;true1&quot;</span>;<br>  <span class="hljs-keyword">boolean</span> b1 = Boolean.parseBoolean(str3);<span class="hljs-comment">//false</span><br>&#125;<br></code></pre></div></td></tr></table></figure></li></ol><hr><h3 id="static-关键字的使用"><a href="#static-关键字的使用" class="headerlink" title="static 关键字的使用"></a>static 关键字的使用</h3><ol><li><p>static：静态的</p></li><li><p>static可以用来修饰属性、方法、代码块、内部类</p><ul><li>用来修饰属性（静态变量/类变量）<ul><li>属性：按是否使用static修饰又分为静态属性和非静态属性（也称为实例变量）。实例变量指我们创建了类的多个对象，每个对象都独立的拥有一套类中的非静态属性。当修改其中一个对象中非静态属性时，不会导致其他对象中同样的属性值的修改。静态变量是指我们创建了类的多个对象，多个对象共享同一个静态变量，当通过某一个对象修改静态变量是，会导致其他对象调用此静态变量时是修改过了的。</li><li>用来修饰属性的其他说明<ol><li>静态变量是随类的加载而加载的，可以通过“类.静态变量”的方式进行调用</li><li>静态变量的加载早于对象的创建</li><li>由于类只会加载一次，则静态变量在内存中也只会存一份，存在方法区的静态域中。</li></ol></li></ul></li><li>用来修饰方法（静态方法）</li></ul><ol><li>随着类的加载而加载，可以通过“类.静态方法”的方式进行调用</li><li>类不能调用非静态方法</li><li>在静态方法中，只能调用静态的方法或属性；在非静态方法中，既可以调用非静态的方法或属性，也可以调用静态的方法或属性</li></ol></li><li><p>static注意点</p><ul><li>在静态的方法中，不能使用this和super</li><li>从生命周期的角度理解静态属性和静态方法</li></ul></li><li><p>static应用</p><ul><li>开发中，如何确定一个属性是否要声明为static的？</li></ul><ol><li>属性是可以被多个对象所共享的，不会随着对象的不同而不同</li><li>类的常量也常常声明为static</li></ol><ul><li>开发中，如何确定一个方法是否要声明为static的？</li></ul><ol><li>操作静态属性的方法，通常设置为static</li><li>工具类中的方法，习惯上声明为static的，比如Math、Array、Collections</li></ol></li></ol><hr><h3 id="单利设计模式"><a href="#单利设计模式" class="headerlink" title="单利设计模式"></a>单利设计模式</h3><ul><li>饿汉式:对象加载的时间会更长；但线程安全<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonTest1</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(Sring[] args)</span></span>&#123;<br>    Bank bank1 = Bank.gerInstance();<br>  &#125;<br>  Class Bank&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">bank</span><span class="hljs-params">()</span></span>&#123;&#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Bank instance = <span class="hljs-keyword">new</span> Bank();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Bank <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>      <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>  &#125; <br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>懒汉式：延迟创建对象可减少加载时长，目前写的这个懒汉式是线程不安全的<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonTest2</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(Sring[] args)</span></span>&#123;<br>    Bank bank1 = Bank.gerInstance();<br>  &#125;<br>  Class Bank&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Bank</span><span class="hljs-params">()</span></span>&#123;&#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Bank instance = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Bank <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>      <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>)<br>      instance = <span class="hljs-keyword">new</span> Bank();<br>      <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>  &#125; <br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="类的成员之四（代码块或初始化块）"><a href="#类的成员之四（代码块或初始化块）" class="headerlink" title="类的成员之四（代码块或初始化块）"></a>类的成员之四（代码块或初始化块）</h3></li></ul><ol><li><p>作用：用来初始化类、对象</p></li><li><p>代码块只能用static来修饰，分为静态代码块和非静态代码块。</p><ul><li>静态代码块：</li><li>内部可以有输出语句随着类的加载而执行，只能执行一次。</li><li>用来初始化类的信息</li><li>非静态代码块：</li><li>内部可以输出语句</li><li>随着对象的创建而执行，没建一个对象就执行一次非静态代码块</li><li>可以再创建对象时，对对象的属性等进行初始化</li><li>若有多个非静态代码块，则按先后顺序执行</li></ul></li><li><p>代码块的结构：</p><ul><li>静态代码块：{}</li><li>非静态代码块：static{}</li></ul></li><li><p>静态代码块优先于非静态代码块执行，代码块优先于构造器执行</p></li><li><p>初始化的原则：由父及子，静态先行</p></li></ol><hr><h3 id="对属性可以赋值的位置"><a href="#对属性可以赋值的位置" class="headerlink" title="对属性可以赋值的位置"></a>对属性可以赋值的位置</h3><ol><li>默认初始化</li><li>显示初始化/在代码块中赋值</li><li>构造器初始化</li><li>有了对象之后，通过对象.属性或对象.方法的方式进行赋值</li><li>上述五点的执行顺序按1–&gt;2/5–&gt;3–&gt;4</li></ol><hr><h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><ol><li>final：最终的</li><li>final可用来修饰类、方法、变量</li><li>final用来修饰一个类：表此类不能被其他类继承，比如有String类、System类、StringBuffer类</li><li>final修饰方法：表明此方法不可以被重写，比如Object中的getClass（）</li><li>final修饰变量：此时的“变量”就称为是一个常量</li><li>final修饰属性，可以考虑赋值的位置有：显示初始化、代码块中初始化、构造器中初始化</li><li>final修饰局部变量：尤其是使用final修饰形参时，表明此形参是一个常量，当我们调用此方法是，给常量形参赋一个实参。一旦赋值以后就只能在方法体内使用此形参，但不能进行重新赋值</li><li>static final 用来把修饰属性：全局变量<h3 id="main方法："><a href="#main方法：" class="headerlink" title="main方法："></a>main方法：</h3></li><li>作为程序的入口</li><li>也是一个普遍的静态方法</li><li>可以作为我们与控制台交互的方式，如将控制台获取的数据传给形参：String[] args，当运行时，输入：java 类名 “Tom” “123” “true”即可，其中类名后面的就是传给形参的数据。<h3 id="abstract关键字"><a href="#abstract关键字" class="headerlink" title="abstract关键字"></a>abstract关键字</h3></li><li>abstract ：抽象的</li><li>abstract可以用来修饰类和方法</li><li>abstract修饰一个类：<ul><li>此类不能实例化</li><li>抽象类中一定有构造器，便于子类实例化调用（涉及子类实例化的全过程）</li><li>开发中，都会提供抽象类的子类，让子类去实例化，完成相关操作</li></ul></li><li>abstract修饰一个方法：<ul><li>抽象方法只能有方法的声明，没有方法体</li><li>包含抽象方法的类，一定是一个抽象类，反之，抽象类可以没有抽象方法</li><li>如子类重写了父类中的所有抽象方法后，此子类方可实例化，如子类没有重写父类中所有的抽象方法，则此类也是一个抽象类，需要使用abstract修饰。</li></ul></li><li>abstract使用上的注意点：<ul><li>abstract不能用来修饰：属性、构造器等结构。</li><li>abstract不能用来修饰私有方法、静态方法、final方法、final类</li></ul></li></ol><hr><h3 id="接口的使用"><a href="#接口的使用" class="headerlink" title="接口的使用"></a>接口的使用</h3><ol><li>关键字：interface</li><li>在java中，接口和类是并列的两个结构</li><li>如何定义接口，定义接口中的成员<ul><li>JDK7及以前：只能定义全局变量和抽象方法</li><li>全局常量：public static final的</li><li>抽象方法：public abstract的<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Flyable</span></span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_SPEED = <span class="hljs-number">7900</span>;<span class="hljs-comment">//全局变量，其中可以省略public static final，但它还在</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span></span>&#123;&#125;<span class="hljs-comment">//抽象方法，也可以省略public abstract</span><br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul></li><li>接口不能定义构造器：意味着接口不可以实例化</li><li>java开发中，接口通过类去实现（implement）的方式来使用，如果实现类覆盖了接口中的所有抽象方法，则此实现类就可以实例化，如果实现类没有覆盖接口中所有的抽象方法，则不能实例化。</li><li>java类可以实现多个接口，弥补了java单继承的局限性，格式：先写继承后写实现<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Class AA extends BB implements CC,DD<br></code></pre></div></td></tr></table></figure></li><li>接口与接口之间是继承，可以多继承</li><li>接口的具体使用，体现多态性</li><li>接口，实际上可以看做是一个规范</li><li>开发中，体会面向接口编程</li><li>在JDK8中，除了定义全局变量和抽象方法之外，还可以定义静态方法和默认方法：<ul><li>接口定义的静态方法，只能通过接口来调用</li><li>通过实现类的对象，可以调用接口中的默认方法，如果实现类重写了接口中的默认方法，调用时，仍然调用的是重写以后的方法。</li><li>如果子类（或实现类）继承的父类和实现的接口中含同名同参数的方法，那么子类在没有重写此方法的情况下，默认调用的是父类中的同名同参数的方法。（类优先原则）</li><li>如果实现类实现了多个接口，而这多个接口定义了同名同参数的默认方法，那么在实现类没有重写此方法的情况下，报错（接口冲突），这就需要我们必须在实现类中重写此方法。</li><li>如何在子类（或实现类）的方法中调用父类接口中被重写的方法<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Mythod</span><span class="hljs-params">()</span></span>&#123;<br>  method3();<span class="hljs-comment">//调用的是自己定义的重写的方法</span><br>  <span class="hljs-keyword">super</span>.method();<span class="hljs-comment">//调用的是父类中声明的</span><br>  接口名.<span class="hljs-keyword">super</span>.method();<span class="hljs-comment">//调用的是接口中默认的方法。</span><br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul></li></ol><hr><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><ol><li>java中允许将一个类A声明在另一个类B中，则类A就是内部类，类B称为外部类</li><li>内部类的分类：成员内部类和局部内部类<ul><li>成员内部类：类内可以定义属性、方法、构造器等，可以被final、abstract修饰；作为外部类的成员，可以调用外部类的结构，可以被static修饰</li><li>局部内部类：局部可以认为是在外部类中的构造器中、代码块中、方法体内</li></ul></li></ol><hr><h3 id="异常的体系结构"><a href="#异常的体系结构" class="headerlink" title="异常的体系结构"></a>异常的体系结构</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">java.lang.Throwable<br>      |_______java.lang.Error:一般不编写针对性的代码进行处理<br>      |_______java.lang.Exception:可以进行异常的处理<br>          |_______编译时异常（checkd）<br>              |_______IOException<br>                  |______FileNotFoundException<br>              |_______ClassNotFoundException<br>          |_______运行时异常（unchecked）<br>              |_______NullPointerException<br>              |_______ArrayIndexOutOfBoundsException<br>              |_______ClassCastException<br>              |_______NumberFormatException<br>              |_______InputMismatchException<br>              |_______ArithemticExdception<br></code></pre></div></td></tr></table></figure><ol><li>异常的处理：抓抛模型<ul><li>过程一：“抛”，程序正在执行的过程中，一旦出现异常，就会在异常代码处生成一个对应异常的对象，并将此对象抛出，一旦抛出对象以后，其后的代码就不再执行</li><li>关于异常对象的产生：</li><li>系统自动生成的异常对象</li><li>手动的生成一个异常对象</li><li>过程二：“抓”，可以理解为异常的处理方式</li><li>try-catch-finally</li><li>throws</li></ul></li><li>try-catch-finally的使用<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br><br>&#125;<span class="hljs-keyword">catch</span>(异常类型|变量名<span class="hljs-number">1</span>)&#123;<br><br>&#125;<span class="hljs-keyword">catch</span>(异常类型|变量名<span class="hljs-number">2</span>)&#123;<br><br>&#125;...<br><span class="hljs-keyword">finally</span>&#123;<br>  一定会执行的代码<br>&#125;<br><br></code></pre></div></td></tr></table></figure>使用说明：</li></ol><ul><li>finally是可选的</li><li>使用try将可能出现异常代码包装起来，在执行过程中，一旦出现异常，就会生成一个对应异常类的对象，根据此对象的类型，去catch中进行匹配</li><li>一旦try中的异常对象匹配到某一个catch时，就进入catch中进行异常的处理，一旦处理完成，就跳出当前的try-catch结构（在没有写finally的情况）继续执行其后的代码。</li><li>catch中的异常类型如果没有子父类关系，则谁声明在上，谁声明在下无所谓<br>catch的异常类型如果满足子父类关系，则要求子类一定声明在父类的上面，否则，报错</li><li>常用的异常对象处理方式：<ul><li>String getMessage（）</li><li>printStackTrace（）</li></ul></li><li>在try结构中声明的变量，再出了try结构以后，就不能在调用</li><li>在try-catch-finally处理编译时异常，使得程序在编译时不再报错，但是运行时仍然可能报错，相当于我们使用try-catch-finally将一个编译时可能出现的异常延迟到运行时出现</li><li>在开发中，由于运行时异常比较常见，所以我们通常就不针对运行时异常编写try-catch-finally了，针对编译时异常，一定要考虑异常的处理</li><li>finally的使用：<ul><li>finally中声明的是一定会被执行的代码，即使catch中又出现异常了。try中有return语句，catch中又return语句的情况</li><li>使用数据库连接、输入输出流、网络编程、socket等资源，jvm是不能自动的回收的。我们需要自己手动的进行的资源的释放。此时的资源释放，就需要声明在finally中</li></ul></li></ul><hr><h3 id="异常处理的方式二：throws-异常类型"><a href="#异常处理的方式二：throws-异常类型" class="headerlink" title="异常处理的方式二：throws + 异常类型"></a>异常处理的方式二：throws + 异常类型</h3><ol><li>“throws + 异常类型”写在方法的声明处。指明此方法执行时，可能会抛出的异常类型。一旦当方法体执行时出现异常，仍然在异常代码处生成一个异常类的对象，此对象满足throws后异常类型时，就会被抛出。异常代码后续的代码就不再执行了。</li><li>体会：try-catch-finally：真正的将异常给处理掉了；throws的方式知识将异常抛给了方法的调用者，并没有真正的将异常处理掉。</li><li>开发中，如何选择使用try-catch-finally，还是使用throws<ul><li>如果父类中被重写的方法没有throws方式处理异常，则子类重写的方法也不能使用throws，意味着如果子类重写的方法中有异常，必须使用try-catch-finally方式处理</li><li>执行的方法中，先后又调用了另外的几个方法，这几个方法是递进关系执行的，我们建议这几个方法使用throws</li></ul></li></ol><hr><h3 id="用户自定义异常"><a href="#用户自定义异常" class="headerlink" title="用户自定义异常"></a>用户自定义异常</h3><ol><li><p>如何自定义异常类</p><ul><li>继承于现有的异常结构：RuntimeException、Exception</li><li>提供全局变量：serialVersion</li><li>提供构造器</li></ul></li><li><p>throw与throws</p><ul><li>throw:表示抛出一个异常类的对象。生成异常对象的过程，声明在方法体内</li><li>throws：属于异常处理的一种方式，声明在方法的声明处</li></ul></li></ol><hr><h2 id="java高级"><a href="#java高级" class="headerlink" title="java高级"></a>java高级</h2><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><ol><li>多线程的创建的方式：<ul><li>方式一：继承于Thread类</li></ul><ol><li>创建一个继承Thread类的子类</li><li>重写Thread类的run()</li><li>创建Thread类的子类的对象</li><li>通过此对象调用start()</li></ol><ul><li>方式二：实现Runnable接口</li></ul><ol><li>创建一个实现了Runnable接口的类</li><li>实现类去实现Runnable中抽象方法：run();</li><li>创建实现类的对象</li><li>将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象</li><li>通过Thread类的对象调用start():启动线程–&gt;调用当前线程的run()–&gt;调用了Runnable类型的target的run();</li></ol></li><li>Thread中常用的方法<ul><li>start():启动当前线程，调用当前线程的run();</li><li>run():通过需要重写Thread类中的此方法，将创建的线程要执行的操作声明在方法中</li><li>currentThread():静态方法，返回执行当前代码的线程</li><li>getName():获取当前线程的名字</li><li>setName():设置当前线程的名字</li><li>yield():释放当前cpu的执行权</li><li>join():在线程a中调用线程b中的join(),此时线程a中就进入阻塞状态，知道线程b完全执行完以后，线程a才结束阻塞状态</li><li>stop():已过时，当执行此方法时，强制结束当前的线程</li><li>sleep(long millitime):让当前线程“睡眠”指定的毫秒数，在指定的睡眠时间内，当前线程是阻塞的</li></ul></li><li>比较创建线程的两种方式<ul><li>开发中：优先选择实现Runnable接口的方式，原因如下</li><li>实现的方式没有类的单继承的局限性</li><li>实现的方式更适合来处理多个线程有共享数据的情况</li><li>联系：Thread类也实现了Runnable接口</li><li>相同点：两种方式都需要重写run()，将线程要执行的逻辑声明在run()中</li></ul></li><li>线程的生命周期：如下图所示<br><img src="https://i.loli.net/2021/04/14/KAkCMOgtoqnN8zx.png" alt="线程生命周期图解"></li><li>线程的同步机制<ul><li>方式一：同步代码块<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (同步代码块)&#123;<br>  <span class="hljs-comment">//需要被同步的代码，操作共享数据的代码</span><br>&#125;<br><span class="hljs-comment">//说明:1.共享数据：多个线程共同操作的变量，例如抢的火车票就是共享数据。2.同步监视器，俗称锁，任何一个类的对象都可以用来充当锁。多个线程必须要共用统一把锁 3.在实现Runnable接口创建多线程的方式中，我们可以考虑使用this充当同步监视器。</span><br></code></pre></div></td></tr></table></figure></li></ul></li></ol><ul><li>方式二：同步方法–&gt;如果操作共享数据的代码完整的声明在一个方法中，我们不妨将此方法声明为同步的</li></ul><ol><li>同步方法仍然涉及到同步监视器，只是不需要我们显示的声明</li><li>非静态的同步方法，同步监视器是：this；静态的同步方法，同步监视器是当前类本身。</li></ol><ul><li>同步的方式解决了线程的安全问题。但操作同步代码时，只能有一个线程参与，其他线程等待，相当于是一个单线程的过程，效率低。</li><li>方式三：lock锁…jdk5.0新增</li><li>步骤：</li></ul><ol><li>实例化ReentrantLock</li><li>调用lock()方法</li><li>调用解决方法unlock()</li><li>将单例模式中的懒汉式进行改写–&gt;使用同步机制使其线程安全:方式一如下：<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function">Class <span class="hljs-title">Bank</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Bank</span><span class="hljs-params">()</span></span>&#123;&#125;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Bank instance = <span class="hljs-keyword">null</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Bank <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">//同步方法的方式</span><br>    <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>)&#123;<br>      instance = <span class="hljs-keyword">new</span> Bank();<br>    &#125;<br>    <span class="hljs-keyword">return</span> instance;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function">Class <span class="hljs-title">Bank</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Bank</span><span class="hljs-params">()</span></span>&#123;&#125;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Bank instance = <span class="hljs-keyword">null</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Bank <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">//同步代码块的方式</span><br>    <span class="hljs-keyword">synchronized</span> (Bank.class)&#123;<br>      <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>)&#123;<br>        instance = <span class="hljs-keyword">new</span> Bank();<br>    &#125;<br>      <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>   <br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>方式二如下：效率相较于上面的更高一些<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Bank <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>)&#123;<br>    <span class="hljs-keyword">synchronized</span> (Bank.class)&#123;<br>      <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>)&#123;<br>        instance = <span class="hljs-keyword">new</span> Bank();<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> instance;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>线程的死锁问题<ul><li>死锁的理解：不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁</li><li>说明：</li><li>出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续</li><li>我们使用同步时，要避免出现死锁</li><li>解决办法：</li><li>专门的算法、原则</li><li>尽量减少同步资源的定义</li><li>尽量避免嵌套同步</li></ul></li><li>面试题：synchronized与lock的异同<ul><li>相同：都能解决线程安全问题</li><li>不同：synchronized机制在执行相应的同步代码块以后，自动的释放同步监视器，lock需要手动的启动同步lock(),同时结束同步也需要手动的实现unlock()</li><li>三种解决同步问题的方式的优先选择顺序：lock–&gt;同步代码块–&gt;同步方法</li></ul></li></ol><hr><h3 id="线程的通信："><a href="#线程的通信：" class="headerlink" title="线程的通信："></a>线程的通信：</h3><ul><li>线程通信的例子，使用两个线程打印1-100.线程1、线程2交替打印</li><li>涉及到三个方法：<ul><li>wait():一旦执行此方法，当前线程就进入阻塞状态，并释放同步监视器</li><li>notify():一旦执行此方法，就会唤醒被wait的线程。如果有多个线程被wait，就唤醒优先级高的那个。</li><li>notifyAll():一旦执行此方法，就会唤醒所有被wait的线程</li><li>说明：上述三个方法使用在线程通信时，三个方法必须使用在同步代码块或同步方法中；方法的调用者必须是同步代码块或同步方法中的同步监视器，否则，或出现IllegalMonitorstateException异常；三个方法是定义在Java.lang.object类中</li></ul></li></ul><hr><ul><li>面试题：sleep()和wait()的异同<ul><li>相同点：一旦执行此方法，都可以是的当前线程进入阻塞状态</li><li>不同点：<ol><li>两个方法声明位置不同：Thread类中声明sleep(),Object类中声明wait()</li><li>调用的要求不同：sleep()可在任何需要的情景下调用，wait必须使用在同步代码块或同步方法中</li><li>关于是否释放同步监视器，如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，wait会释放锁。</li></ol></li></ul></li></ul><hr><h3 id="jdk5-0新增线程创建方式"><a href="#jdk5-0新增线程创建方式" class="headerlink" title="jdk5.0新增线程创建方式"></a>jdk5.0新增线程创建方式</h3><ul><li>新增方式一：实现callable接口<ol><li>创建一个实现callable的实现类</li><li>实现call方法，将此线程需要执行的操作声明在call中</li><li>创建callable接口实现类的对象</li><li>将此callable接口实现类的对象作为传递到futureTask构造器中，创建的futureTask的对象</li><li>将futureTask的对象作为参数，callable实现类重写的call()的返回值，并调用start()</li><li>获取callable中call方法的返回值</li></ol></li><li>如何解释实现callable接口的方式创建多线程比实现Runnable接口创建多线程方式强大。<ol><li>call()方法可以有返回值</li><li>call()可以抛出异常，被外面的操作捕获，获取异常的信息</li><li>callable是支持泛型的</li></ol></li><li>新增方式二：使用线程池（开发中常用）</li></ul><hr><p>Java常用类：</p><ul><li>String类<ol><li>String类：代表字符串，使用一对””引起来表示；属于final类，不可以被继承，内容存储在一个字符数组value[]中的；实现了serializable接口：表示字符串是支持序列化的；实现了comparable接口：表示string可以比较大小。</li><li>string代表不可变的字符序列，简称：不可变性。体现：当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。<br><code>String s1 = &quot;abc&quot;;//字面量的定义方式</code></li><li>通过字面量的方式（区别于new（））给一个字符串赋值，此时的字符串值声明在字符串常量池中</li><li>字符串常量池中是不会储存相同内容的字符串的</li><li>面试题：String s = new String(“abc”)方式创建对象，在内存中创建了几个对象？答：两个，一个是在堆空间中new的结构，另一个是char[]对应的常量池中的数据”abc”</li><li>String与char[]之间的转换</li></ol><ul><li>String–&gt;char[]:调用String的toCharArray()</li><li>char[]–&gt;String:调用String的构造器<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">String str1 = <span class="hljs-string">&quot;&quot;</span><br></code></pre></div></td></tr></table></figure></li></ul><ol start="7"><li>String与byte[]之间的转换</li></ol><ul><li>String–&gt;byte[]:调用String的getBytes(),该转换过程为编码过程</li><li>byte[]–&gt;String:String str = new String(bytes):使用默认的字符集进行解码</li></ul></li><li>结论：<ol><li>常量与常量的拼接结果在常量池。且常量池中不会存在相同内容的常量 </li><li>只要其中有一个是变量结果就在堆中</li><li>如果拼接的结果调用intern()方法，返回值就在常量池中。</li></ol></li><li>StringBuffer的常用方法：stringBuilder和StringBuffer的常用方法差不多。如下<ol><li>append(xxx):用于字符串的拼接</li><li>delete(int start,int end):删除指定位置的内容</li><li>replace(int start,int end,String str):吧[start,end]位置的字符串替换为str</li><li>insert(int offset,xxx):在指定位置插入xxx</li><li>reverse():把当前字符序列逆转</li><li>int indexof (String str):返回字符串首次出现的位置</li><li>StringsubString(int start,int end):返回String类型从start到end的字符串</li><li>int length(String str):返回字符串长度</li><li>char charAt(int n):返回某一位置的字符</li><li>void setChar(int n,char ch):将某一位置的字符设置为ch</li></ol></li><li>对比String、StringBuffer、StringBuilder三者的效率：从高到低排列：StringBuilder &gt; StringBuffer &gt; String</li><li>String、StringBuffer、StringBuilder三者的异同<ul><li>String为不可变的字符序列，而StringBuffer和StringBuilder都是可变的字符序列</li><li>三者都是底层使用char[]存储</li><li>StringBuilder和StringBuffer之间的异同：StringBuffer线程安全但效率低而StringBuilder则线程不安全但效率高；两者都存在扩容问题：如果要添加的数据底层数组盛不下了，那就需要扩容底层的数组。默认情况下，扩容为原来容量的2倍+2，同时将原有数组中的元素复制到新的数组中.</li><li>指导意见：开发中建议使用StringBuffer(int capacity)或StringBuilder(int capacity)</li></ul></li><li>jdk8之前的日期和时间api<ol><li>System类中的currentTimeMillis()<br><code>long time = System.currentTimeMillis();</code></li><li>数据库中的Date类<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">java.util.Date类<br>      |_____java.sql.Date类<br><span class="hljs-comment">//两个方法的使用： 1.toString()：显示当前的年月日时分秒</span><br><span class="hljs-comment">//                2.getTime():获取当前Date对象对应的毫秒数</span><br><span class="hljs-comment">//两个构造器的使用：1.Date date1 = new Date();创造一个对应当前时间的Date对象           2.Date date2 = new Date(1556324563L);创建指定毫秒数的Date对象</span><br></code></pre></div></td></tr></table></figure></li></ol></li><li>jdk8中新日期和时间api:java.time…<ul><li>时间接口主要的实现类：LocalDate(日期)、LocalTime(时间)、LocalDateTime(日期和时间)、DateTimeFormatter(日期和时间的格式)</li><li>时间类的使用，以LocalDateTimehe和DateTimeFormatter为例<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DateTimeFormatetTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        LocalDateTime localDateTime = LocalDateTime.now();<span class="hljs-comment">//获取当前的时间</span><br>        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<span class="hljs-comment">//为时间设置指定格式</span><br>        String str = localDateTime.format(formatter);<span class="hljs-comment">//将时间按指定格式转换，并返回一个结果的字符串</span><br>        System.out.println(str);<br>    &#125;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stringToLocalDateTime</span><span class="hljs-params">()</span></span>&#123;<br>        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<span class="hljs-comment">//设置时间为指定格式</span><br>        LocalDateTime localDateTime = LocalDateTime.parse(<span class="hljs-string">&quot;2021-04-17 14:43:10&quot;</span>,formatter);<span class="hljs-comment">//按指定格式解析传入的时间字符串</span><br>        System.out.println(localDateTime);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="Java比较器"><a href="#Java比较器" class="headerlink" title="Java比较器"></a>Java比较器</h3></li></ul></li><li>说明：Java中的对象，正常情况下，只能进行比较：==或!=,不能使用 &gt; 或 &lt; 的，但是在开发的场景中，我们需要对多个对象进行排序，言外之意，就需要比较对象的大小，如何实现？使用两个接口中的任何一个：comparable或comparator</li><li>comparable接口的使用<ul><li>像String、包装类等实现了comparable接口，重写了compareTo()方法，进行了从小到大的排列。</li><li>重写compareTo(obj)的规则</li></ul><ol><li>如果当前对象的this的某一属性大于形参obj的某一属性，则返回正整数。</li><li>同上，小于的话，返回负整数。</li><li>同上，等于的话，返回零。</li></ol></li><li>对于自定义类，如果需要排序，我们可以让自定义的类实现comparable接口，重写compareTo(obj)方法，在compareTo(obj)方法中指明按什么样的方式排序。例子如下：<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 指明人比较大小的方式：按年龄从小到大排序</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> Person) &#123;<br>            Person p = (Person) o;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.age &gt; p.age) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.age &lt; p.age)&#123;<br>                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;传入的数据类型不一致&quot;</span>);<br>    &#125;<br><span class="hljs-comment">//下面是测试用例</span><br><span class="hljs-meta">@Test</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>        Person[] per = <span class="hljs-keyword">new</span> Person[<span class="hljs-number">4</span>];<br>        per[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;lf&quot;</span>,<span class="hljs-number">24</span>);<br>        per[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;lw&quot;</span>,<span class="hljs-number">20</span>);<br>        per[<span class="hljs-number">2</span>] = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;lwz&quot;</span>,<span class="hljs-number">21</span>);<br>        per[<span class="hljs-number">3</span>] = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;lxz&quot;</span>,<span class="hljs-number">23</span>);<br>        Arrays.sort(per);<br>        System.out.println(Arrays.toString(per));<br>    &#125;<br></code></pre></div></td></tr></table></figure></li><li>comparator接口的使用：定制排序<ul><li>背景：当元素的类型没有实现java.lang.comparable接口而又不方便修改密码，或者实现了java.lang.comparable接口的排序规则不适合当前的操作</li><li>重写compare(Object o1,Object o2)方法，比较o1和o2的大小：如果返回正整数，则表示o1大于o2;返回负整数，表示小于；返回零，表示相等。</li><li>例子如下：<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;<br>       Person[] per = <span class="hljs-keyword">new</span> Person[<span class="hljs-number">5</span>];<br>       per[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;lf&quot;</span>,<span class="hljs-number">24</span>);<br>       per[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;fw&quot;</span>,<span class="hljs-number">21</span>);<br>       per[<span class="hljs-number">2</span>] = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;fw&quot;</span>,<span class="hljs-number">20</span>);<br>       per[<span class="hljs-number">3</span>] = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;xz&quot;</span>,<span class="hljs-number">23</span>);<br>       per[<span class="hljs-number">4</span>] = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;lz&quot;</span>,<span class="hljs-number">23</span>);<br>       Arrays.sort(per, <span class="hljs-keyword">new</span> Comparator() &#123;<br>           <span class="hljs-comment">//指明person比较大小的方式：先按照person的年龄从高到低排序，再按照person的姓名从低到高排序</span><br>           <span class="hljs-meta">@Override</span><br>           <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Object o1, Object o2)</span> </span>&#123;<br>               <span class="hljs-keyword">if</span> (o1 <span class="hljs-keyword">instanceof</span> Person &amp;&amp; o2 <span class="hljs-keyword">instanceof</span> Person) &#123;<br>                   Person p1 = (Person)o1;<br>                   Person p2 = (Person)o2;<br>                   <span class="hljs-keyword">if</span> (p1.getAge() == p2.getAge()) &#123;<br>                       <span class="hljs-keyword">return</span> p1.getName().compareTo(p2.getName());<br>                   &#125;<span class="hljs-keyword">else</span> &#123;<br>                       <span class="hljs-keyword">return</span> p1.compareTo(p2);<br>                   &#125;<br>               &#125;<br>               <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;传入的数据类型不一致&quot;</span>);<br>           &#125;<br>       &#125;);<br>       System.out.println(Arrays.toString(per));<br>   &#125;<br><br></code></pre></div></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java基本语法</title>
    <link href="/2021/03/21/java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    <url>/2021/03/21/java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="java基本语法"><a href="#java基本语法" class="headerlink" title="java基本语法"></a>java基本语法</h2><h2 id="标识符的命名规则"><a href="#标识符的命名规则" class="headerlink" title="标识符的命名规则"></a>标识符的命名规则</h2><ul><li>由26个大小写英文字母，0-9，_或$组成</li><li>数字不可以开头</li><li>不可以使用关键字和保留字，但能包含关键字和保留字</li><li>Java中严格区分大小写，长度无限制</li><li>标识符不能包含空格<h2 id="Java中的名称命名规范"><a href="#Java中的名称命名规范" class="headerlink" title="Java中的名称命名规范"></a>Java中的名称命名规范</h2></li><li>包名：多单词组成是所有字母都小写: xxxxyyyyyzzzz</li><li>类名、接口名：多单词组成时，所有单词的首字母大写：XxxxYyyyyZzzz</li><li>变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词的首字母都大写</li><li>常量名：所有字母都大写，多单词时每个单词用下划线连续:  XXX_YYY_ZZZ<h2 id="Java变量的使用"><a href="#Java变量的使用" class="headerlink" title="Java变量的使用"></a>Java变量的使用</h2></li><li>必须是要先声明、赋值之后，才可以使用。否则编译不通过</li><li>变量只能在作用域内起作用。<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3></li><li>整型：byte short int long     其中 long型赋值是须加上“l”或者“L”，若没加，则被机器识别为int型，但编译不会报错：例如 ：long a=1234 </li><li>浮点型： float double  其中float型赋值时必须加上“f”或者“F”，若没加，编译报错</li><li>字符型： char:    cahr c = ‘a’ –&gt; c=97      cahr c = ‘A’ –&gt; c=65</li><li>布尔型： Boolean：true/flase<br>特别的：整型常量 默认类型为int型，浮点型常量 默认类型为double型：例如：byte b = 12; byte b1 = b + 1;(会发生编译失败)–&gt;应改为 int b1= b + 1<br>浮点的例子类似<h3 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h3></li><li>String：</li><li>声明String类型的变量时。使用一对双引号“”<br>例：String s1 = “hello world”;<br>String s2 = “a”;<br>String s3 = “”; 三种都可以<br>与char相比 ,char c = ‘ ‘ 可以，但 char c =’’不可以，编译不通过</li><li>String可以和8种数据类型变量做运算，且运算只能是连接运算,通过+来连接 ，运算的结果仍是String类型 例如练习1</li><li>注意：当String和其他类型的变量做运算时，要区分“+”是代表加法运算还是连接运算：例如练习2和3<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//练习1</span><br><span class="hljs-keyword">int</span> number = <span class="hljs-number">1001</span>;<br>String numberStr = <span class="hljs-string">&quot;学号：&quot;</span>；<br>String info = numberStr + number;<span class="hljs-comment">// +：连接运算</span><br>Boolean b1 = <span class="hljs-keyword">true</span>;<br>String info1 = info + b1;<span class="hljs-comment">//+连接运算</span><br>System.out.println(info1);<span class="hljs-comment">//结果为：“学号：1001true”</span><br>--------------------------------------------------<br><span class="hljs-comment">//练习2</span><br><span class="hljs-keyword">char</span> c = <span class="hljs-string">&#x27;a&#x27;</span>;<br><span class="hljs-keyword">int</span> num = <span class="hljs-number">10</span>;<br>String str = <span class="hljs-string">&quot;hello&quot;</span>;<br>System.out.println(c + num + str);<span class="hljs-comment">//结果：107hello</span><br>System.out.println(c + str + num);<span class="hljs-comment">//结果：ahello10</span><br>----------------------------------------------------<br><span class="hljs-comment">//练习3</span><br>System.out.println(<span class="hljs-string">&quot;*   *&quot;</span>);<span class="hljs-comment">//结果：*  *</span><br>System.out.println(<span class="hljs-string">&#x27;*&#x27;</span> + <span class="hljs-string">&#x27;\t&#x27;</span> + <span class="hljs-string">&#x27;*&#x27;</span>);<span class="hljs-comment">//结果：93  42+9+42</span><br>System.out.println(<span class="hljs-string">&#x27;*&#x27;</span> + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&#x27;*&#x27;</span>);<span class="hljs-comment">//结果:*  *</span><br></code></pre></div></td></tr></table></figure><blockquote><h3 id="自动类型提升"><a href="#自动类型提升" class="headerlink" title="自动类型提升"></a>自动类型提升</h3></blockquote></li><li>结论：当容量小的数据类型的变量与容量大的数据类型的变量做运算时，结果自动提升为容量最大的数据类型。</li><li>-&gt; :  byte(1个字节)、char(2)、short(2)–&gt;int(4)–&gt;long(8)–&gt;float(4)–&gt;double(8)  特别的：当byte、char和short三种类型的变量做运算时，结果为int型。<blockquote><h3 id="强制类型转换："><a href="#强制类型转换：" class="headerlink" title="强制类型转换："></a>强制类型转换：</h3></blockquote></li><li>使用( ) 有可能会损失精度:例如：double a=12.3    double b=(int)a    结果为b=12<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3></li><li>%： 取余运算：结果的符号与被模数的符号相同</li><li>++、–：自增自减：注意点如下：<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">short</span> s1 = <span class="hljs-number">10</span>;<br>s1 = s1 + <span class="hljs-number">1</span>;<span class="hljs-comment">//会编译失败，因为s1加1之后为int型</span><br>s1 = (<span class="hljs-keyword">short</span>)(s1 + <span class="hljs-number">1</span>);<span class="hljs-comment">//编译正确</span><br>s1++;<span class="hljs-comment">//若直接s1++，自增1不会改变本身变量的数据类型</span><br><span class="hljs-comment">//同理：</span><br>s1 += <span class="hljs-number">2</span>;<span class="hljs-comment">//也不会改变变量自身的数据类型</span><br>改变两个变量的值<br><span class="hljs-comment">//方式一：定义临时变量</span><br><span class="hljs-keyword">int</span> num1 = <span class="hljs-number">10</span>,num2 = <span class="hljs-number">20</span>;<br><span class="hljs-keyword">int</span> temp = num1;<br>num1 = num2;<br>num2 = temp;<br><span class="hljs-comment">//方式二：两数相加; 虽然不用定义临时变量，但相加操作    可能会超出储存范围且只能适用于数值类型；</span><br>num1 = num1 + num2;<br>num2 = num1 - num2;<br>num1 =num1 - num2;<br><span class="hljs-comment">//方式三：使用位运算符； 也只能适用于数值类型 ：原理：一个数连续 ^ 上同一个数，结果等于它本身</span><br>num1 = num1 ^ num2;<br>num2 = num1 ^ num2;<br>num1 = num1 ^ num2;<br></code></pre></div></td></tr></table></figure><h2 id="获取一个随机数"><a href="#获取一个随机数" class="headerlink" title="获取一个随机数"></a>获取一个随机数</h2></li><li>获取一个在[a,b]范围的随机数公式： (int)(Math.random() * (b-a+1))+a<br>//如果要取一个[10-99]范围的随机数<br>int a = (int)(Math.random() * 90 +10)<br>break和continue的异同以及特殊情况</li><li>默认情况下：相同点：break和continue都是对最近一层循环起作用<br>不同点：break，跳出最近的整个循环；continue，结束当前循环的一次循环</li><li>特殊情况：可以指定break和continue作用于哪个循环；例子如下：<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">table:<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">3</span> ; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span> ; j &lt; i ; j++)&#123;<br>        System.out.println(*);<br>        <span class="hljs-keyword">continue</span> table;<span class="hljs-comment">//结束第一层循环的一次循环</span><br>    &#125;       <br>&#125;<br>table:<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">3</span> ; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span> ; j &lt; i ; j++)&#123;<br>        System.out.println(*);<br>        <span class="hljs-keyword">break</span> table;<span class="hljs-comment">//结束第一层循环</span><br>    &#125;       <br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="数组的基本操作"><a href="#数组的基本操作" class="headerlink" title="数组的基本操作"></a>数组的基本操作</h2></li><li>数组的复制、反转<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        String[] arr = <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;JJ&quot;</span>,<span class="hljs-string">&quot;DD&quot;</span>,<span class="hljs-string">&quot;MM&quot;</span>,<span class="hljs-string">&quot;BB&quot;</span>,<span class="hljs-string">&quot;GG&quot;</span>,<span class="hljs-string">&quot;AA&quot;</span>&#125;;<br>        <span class="hljs-comment">//数组的复制（区别于数组变量的赋值：arr1=arr）:相当于剪切操作</span><br>        String[] arr1 = <span class="hljs-keyword">new</span> String[arr.length];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr1.length; i++)&#123;<br>            arr1[i] = arr[i];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr1.length; i++) &#123;<br>            System.out.print(arr1[i]+<span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">//数组的反转1</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; arr.length / <span class="hljs-number">2</span>; i++)&#123;<br>            String temp = arr[i];<br>            arr[i] = arr[arr.length - i -<span class="hljs-number">1</span>];<br>            arr[arr.length -i -<span class="hljs-number">1</span>] = temp;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            System.out.print(arr[i]+<span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">//数组的反转2</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j =arr.length - <span class="hljs-number">1</span>;i &lt; j; i++, j--)&#123;<br>            String temp = arr[i];<br>            arr[i] = arr[j];<br>            arr[j] = temp;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            System.out.print(arr[i]+<span class="hljs-string">&quot;\t&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>数组的二分查找<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//二分法查找</span><br><span class="hljs-comment">//前提：所要查找的数组必须有序。</span><br><span class="hljs-keyword">int</span>[] arr2 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;-<span class="hljs-number">12</span>,-<span class="hljs-number">9</span>,-<span class="hljs-number">3</span>,-<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">45</span>,<span class="hljs-number">102</span>&#125;;<br><span class="hljs-keyword">int</span> dest = -<span class="hljs-number">2</span>;<br><span class="hljs-keyword">int</span> head = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> end = arr2.length - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">boolean</span> isFlag = <span class="hljs-keyword">true</span>;<br><span class="hljs-keyword">while</span>(head &lt;= end)&#123;<span class="hljs-comment">//注意是 &lt;=</span><br>    <span class="hljs-keyword">int</span> middle = (head + end) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(arr2[middle] == dest)&#123;<br>        System.out.println(<span class="hljs-string">&quot;元素找到，其位置为&quot;</span>+ middle);<br>        isFlag = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr2[middle] &lt; dest)&#123;<br>        head = middle + <span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">else</span><br>        end = middle - <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(isFlag)&#123;<br>    System.out.println(<span class="hljs-string">&quot;很遗憾没有找到！&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VScode终端填坑</title>
    <link href="/2021/03/03/VScode%E7%BB%88%E7%AB%AF%E5%A1%AB%E5%9D%91/"/>
    <url>/2021/03/03/VScode%E7%BB%88%E7%AB%AF%E5%A1%AB%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<h2 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h2><ul><li>使用PowerShell时报错：此系统禁止运行脚本<br><img src="https://i.loli.net/2021/03/03/ZUbRfrJay52N1Qg.png" alt="报错样图"></li></ul><hr><h2 id="快速解决方法"><a href="#快速解决方法" class="headerlink" title="快速解决方法:"></a>快速解决方法:</h2><ul><li>在VS code的PowerShell终端输入以下命令即可<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">Set-ExecutionPolicy RemoteSigned<br></code></pre></div></td></tr></table></figure></li><li>详细解决方案参考<a href="https://go.microsoft.com/fwlink/?LinkID=135170">这里</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>VScode PowerShell</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>

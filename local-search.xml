<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>mysql</title>
    <link href="/2021/05/18/mysql/"/>
    <url>/2021/05/18/mysql/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>xilou</title>
    <link href="/2021/03/30/%E5%88%98%E8%8A%B3/"/>
    <url>/2021/03/30/%E5%88%98%E8%8A%B3/</url>
    
    <content type="html"><![CDATA[<h1 id="刘芳"><a href="#刘芳" class="headerlink" title="刘芳"></a>刘芳</h1><h2 id="求职意向"><a href="#求职意向" class="headerlink" title="求职意向"></a>求职意向</h2><p>=========</p><ul><li>Java开发工程师</li></ul><hr><h2 id="个人信息"><a href="#个人信息" class="headerlink" title="个人信息"></a>个人信息</h2><p>=========</p><ul><li>性 别：男                     年 龄：24</li><li>手 机：14779732375            邮 箱：<a href="mailto:&#x36;&#x37;&#49;&#x35;&#54;&#x32;&#x31;&#x36;&#x30;&#64;&#x71;&#113;&#46;&#x63;&#x6f;&#109;">&#x36;&#x37;&#49;&#x35;&#54;&#x32;&#x31;&#x36;&#x30;&#64;&#x71;&#113;&#46;&#x63;&#x6f;&#109;</a></li><li>专 业：计算机科学与技术       个人博客：<a href="https://xilou37.github.io/">https://xilou37.github.io/</a></li></ul><hr><h2 id="教育经历"><a href="#教育经历" class="headerlink" title="教育经历"></a>教育经历</h2><p>=========</p><ul><li>燕京理工学院     2017.9~2021.7     本科</li></ul><hr><h2 id="专业技能"><a href="#专业技能" class="headerlink" title="专业技能"></a>专业技能</h2><p>=========</p><ul><li>掌握Java基础知识，具备良好的编程习惯以及代码规范</li><li>熟练使用MySQL数据库，会编写基本的SQL语句</li><li>熟练使用Linux系统常用命令 </li><li>了解运用常见的Java开发框架：SpringMVC,MyBatis,SpringBoot</li><li>熟悉使用eclipse、idea等开发工具</li><li>其它<ul><li>英语过四级，可以更轻松的阅读技术文档</li><li>计算机过二级，熟练使用office软件<h2 id="项目经历"><a href="#项目经历" class="headerlink" title="项目经历"></a>项目经历</h2>=========</li></ul></li><li><strong>项目一 : 网上书城</strong><ul><li><blockquote><p><strong>项目描述</strong>:  Javaweb项目，主要实现了用户的登入注册模块、购物车模块、订单模块、图书管理模块。</p></blockquote></li><li><blockquote><p><strong>技术描述：</strong></p></blockquote><ul><li>jQuery，XML&amp;Tomcat，Servlet，jsp，EL表达式&amp;JSTL标签库，cookie和session，Filter过滤器，JSON和Ajax请求&amp;i18n国际化。</li></ul></li></ul></li><li><strong>项目二 : 客户管理系统</strong><ul><li><blockquote><p><strong>项目描述</strong>:  该客户管理系统是一个Javaweb项目，主要实现了对客户信息的CRUD操作。</p></blockquote></li><li><blockquote><p><strong>技术描述：</strong></p></blockquote><ol><li>基础框架：ssm(SpringMVC+Spring+MyBatis)</li><li>数据库：MySQL</li><li>前端框架：bootstrap快速搭建简洁美观的界面</li><li>项目的依赖管理：Maven</li><li>分页：pageHelper</li><li>逆向工程：MyBatis Generator</li></ol></li></ul></li></ul><h2 id="自我评价"><a href="#自我评价" class="headerlink" title="自我评价"></a>自我评价</h2><p>=========</p><ul><li>喜欢编程开发</li><li>善于积累学到的知识</li><li>做事认真，待人诚恳</li><li>谢谢您阅读我的简历</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>简历</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java面向对象</title>
    <link href="/2021/03/25/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <url>/2021/03/25/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="java面向对象"><a href="#java面向对象" class="headerlink" title="java面向对象"></a>java面向对象</h2><h3 id="对象数组的内存解析"><a href="#对象数组的内存解析" class="headerlink" title="对象数组的内存解析"></a>对象数组的内存解析</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Student[] stus = <span class="hljs-keyword">new</span> Student[<span class="hljs-number">5</span>];<br>stus[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> Student();<br><span class="hljs-comment">//下面是类结构</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>&#123;<br>    <span class="hljs-keyword">int</span> number;<br>    <span class="hljs-keyword">int</span> state;<br>    <span class="hljs-keyword">int</span> score;<br>&#125; <br></code></pre></div></td></tr></table></figure><ul><li>当执行第一行代码时，计算机会在内存进行如下操作：</li></ul><ol><li>在堆中开辟一块拥有首地址的内存块，容量单位为5</li><li>在栈中存入刚才开辟的首地址</li></ol><ul><li>当执行第二行代码时，计算机会在内存进行如下操作：</li></ul><ol><li>在堆中创建存放学生类数据的区域</li><li>在该区域的首地址存入上一行代码创建的内存块中第一个位置</li></ol><ul><li><strong><em>内存解析的说明</em></strong>  </li></ul><ol><li>引用类型的变量，只可能存储两类值：null 或 地址值（含变量的类型）</li></ol><hr><h3 id="匿名对象的使用"><a href="#匿名对象的使用" class="headerlink" title="匿名对象的使用"></a>匿名对象的使用</h3><ul><li>理解： 我们创建的对象，没有显示的赋给一个变量名，即为匿名对象</li><li>特征：匿名对象只能调用一次</li><li>使用：如下<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InstanceTest</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        PhoneMall mall = <span class="hljs-keyword">new</span> PhoneMall();<br>        mall.show(<span class="hljs-keyword">new</span> Phone());<span class="hljs-comment">//此处是匿名对象的使用，在传参的时候进行赋值</span><br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PhoneMall</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(Phone phone)</span></span>&#123;<br>        phone.sentMail();<br>        phone.playGame();<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Phone</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sentMail</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;手机可以发送短信&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span>  <span class="hljs-title">playGame</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;手机可以玩游戏&quot;</span>);<br>    &#125; <br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><hr><h3 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h3><ul><li>定义：在同一个类中，允许存在一个以上的同名方法，只要他们的参数个数和参数类型不同即可</li><li>判断是否是重载：跟方法的权限修饰符、返回值类型、形参变量名、方法体都没有关系</li></ul><hr><h3 id="可变形参"><a href="#可变形参" class="headerlink" title="可变形参"></a>可变形参</h3><ul><li>格式：(String … str)<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(String ... strs)</span></span>&#123;&#125;<span class="hljs-comment">//形参个数没有指定，按需求传入，因此是可变的；</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(String[] strs)</span></span>&#123;&#125;<span class="hljs-comment">//效果和上面的方法是一样的，一个可变数组去存可变的形参 </span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i;String ... strs)</span></span>&#123;&#125;<span class="hljs-comment">//可变形参位置必须放到其他类型的形参后面</span><br></code></pre></div></td></tr></table></figure></li></ul><hr><h3 id="变量的赋值"><a href="#变量的赋值" class="headerlink" title="变量的赋值"></a>变量的赋值</h3><ul><li><p>如果变量是基本数据类型，此时赋值的是变量所存的具体数据值</p></li><li><p>如果变量是引用数据类型，此时赋值的是变量所报存数据的地址值<br>方法的形参传递机制：值传递</p></li><li><p>形参：方法定义时，声明在小括号内的参数实参：方法调用时，实际传递给形参的数据</p></li><li><p>值传递机制：</p><ul><li>如果参数是基本数据类型，此时实参传给形参的是实参真是储存的数据值</li><li>如果参数是应用数据类型，此时实参传给形参的是实参存储数的地址值</li></ul></li></ul><hr><h3 id="封装性的体现"><a href="#封装性的体现" class="headerlink" title="封装性的体现"></a>封装性的体现</h3><ul><li>我们将某个类的属性私有化（Private），然后提供公共的（Public）set 和 get 方法去获取或则修改类的属性</li><li>封装性的体现，需要权限修饰符来体现：</li></ul><ol><li>Java规定的4中权限（从小到大排列）：private,缺省，protected，public</li><li>4种全限修饰符可以用来修饰类及类的内部结构：属性、方法、构造器、内部类</li><li>具体的：4种权限都可以用来修饰类的内部结构：属性、方法、构造器、内部类</li><li>修饰类的话，只能用：缺省和public</li></ol><ul><li>4种权限修饰符的权限</li></ul><table><thead><tr><th align="center">修饰符</th><th align="center">类内部</th><th align="center">同一个包</th><th align="center">不同包的子类</th><th align="center">同一个工程</th></tr></thead><tbody><tr><td align="center">private</td><td align="center">yes</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">(缺省)</td><td align="center">yes</td><td align="center">yes</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">protected</td><td align="center">yes</td><td align="center">yes</td><td align="center">yes</td><td align="center"></td></tr><tr><td align="center">public</td><td align="center">yes</td><td align="center">yes</td><td align="center">yes</td><td align="center">yes</td></tr></tbody></table><hr><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><ol><li>功能：<br>• 构造对象<br>• 给属性初始化值</li><li>说明：<br>• 如果自己没写构造器的话，系统默认有一个空参构造器<br>• 构造器的格式：权限修饰符    类名    （形参列表）{    }<br>• 一个类中若有多个构造器，彼此之间构成重载<br>• 一旦我们自己定义了类的构造器之后，系统就不再提供默认的空参构造器了<br>• 一个类中，至少会有一个构造器</li><li>总结：属性赋值的先后顺序</li></ol><hr><h3 id="属性赋值的种类"><a href="#属性赋值的种类" class="headerlink" title="属性赋值的种类"></a>属性赋值的种类</h3><ol><li>默认初始化</li><li>显示初始化</li><li>构造器中初始化</li><li>通过”对象 . 方法” 或 “对象 . 属性”的方式，赋值<br>赋值后的先后顺序为：1-&gt;2-&gt;3-&gt;4</li></ol><hr><h3 id="this关键字的使用"><a href="#this关键字的使用" class="headerlink" title="this关键字的使用"></a>this关键字的使用</h3><ol><li>this 可以用来修饰、调用：属性、方法、构造器</li><li>当this修饰属性和方法时：this应理解为：当前对象 或 当正在创建的对象</li></ol><ul><li>一般情况下：<br>无论是在类的方法中还是在类的构造器中，我们都可以使用“this . 属性”或“this . 方法”的方式，调用对象的属性和方法，但我们可以选择省略“this .”</li><li>特殊情况下：<br>当方法的形参或者构造器的形参和类的属性名同名时，我们必须显示的使用 “this .变量”，表明此变量是属性，而非形参</li><li>注意：当this调用构造器时</li></ul><ol><li>我们在类的构造器中，可以显示的使用“this（形参列表）”的方式，调用本类中指定的其他构造器</li><li>构造器中不能通过“this（形参列表）”方式调用自己</li><li>如果一个类中有n个构造器，则最多只能有n-1个构造器中调用了“this（形参列表）”</li><li>规定：“this（形参列表）”必须声明在当前构造器的首行</li><li>构造器内部，最多只能声明一个“this（形参列表）”，用来调用其他构造器</li></ol><hr><h3 id="super关键字的使用"><a href="#super关键字的使用" class="headerlink" title="super关键字的使用"></a>super关键字的使用</h3><ul><li>super理解为：父类的…</li><li>supper可以用来调用：属性、方法、构造器</li><li>super的使用：<ul><li>调用属性和方法<ul><li>我们可以再子类的方法或者构造器中，通过使用“super.属性”或者“super.方法”的方式，显示的调用父类中声明的属性或方法。但是一般省略“super”。</li><li>特殊的：当子类和父类定义了重名的属性时，我们想要在子类中调用父类中声明的属性，则必须显示的使用“super.属性”的方式，表明调用父类中声明的属性。当子类重写了父类的方法以后，我们想要在子类的方法中调用父类中被重写的方法时，则必须显示的使用“super.方法”的方式，表明调用的是父类中被重写的方法。</li></ul></li><li>调用构造器<ul><li>我们可以在子类的构造器中显示的使用“super（形参列表）”的方式，调用父类中声明的指定的构造器。</li><li>“super（形参列表）”的使用，必须声明在子类构造器的首行。</li><li>我们在类的构造器中，针对于“this（形参列表）”或“super（形参列表）”只能二选一，不能同时出现。</li><li>在构造器的首行，若没有显示的调用“this（形参列表）”或者“super（形参列表）”则默认调用的是父类中空参的构造器：super（）。</li><li>在类的多个构造器中，至少有一个类的构造器使用了“super（形参列表）”调用父类中的构造器</li></ul></li></ul></li></ul><hr><h3 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h3><ul><li>好处：<ol><li>减少了代码的冗余，提高代码的复用性</li><li>便于功能的扩展</li><li>为之后多态性的使用提供前提</li></ol></li><li>体现：<ol><li>一旦子类A继承了父类B以后，子类A中获取了父类B中声明的所有属性和方法，同样包含父类中声明private的属性和方法，只是因为封装性的影响，使得子类不能直接调用父类的结构而已。</li><li>子类继承父类之后，还可以声明自己特有的属性和方法，实现功能的扩展。</li><li>关键字：extends：延展，扩展</li></ol></li><li>java关于继承的规定<ol><li>一个类可以被多个子类继承</li><li>一个类只能有一个父类：叫类的单继承性</li><li>子父类是相对的概念：有多层继承的概念</li></ol></li></ul><hr><h3 id="子类对象实例化的全过程"><a href="#子类对象实例化的全过程" class="headerlink" title="子类对象实例化的全过程"></a>子类对象实例化的全过程</h3><ol><li>从结果上来看（继承性）<ul><li>子类继承父类后，就获取了父类中声明的属性和方法，创建子类的对象，在堆空间中，就会加载所有的父类中的声明的属性</li></ul></li><li>从过程上来看<ul><li>当我们通过子类的构造器创建子类对象是，我们一定会直接或间接的调用器父类的构造器，进而调用父类的父类的构造器…直到调用了java.lang.Object类中空参的构造器为止。正因为加载过所有的父类的结构，所以才可以看到内存中有父类中的结构，子类对象可以考虑进行调用。</li></ul></li><li>明确：虽然创建子类对象时，调用了父类的构造器，但是自始至终就创建过一个对象，即为new的子类对象。</li></ol><hr><h3 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h3><ol><li>理解：可以理解为一个事物的多种形态。</li><li>何为多态性：父类的引用指向子类的对象。例如下列代码：<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//父类person有两个子类man和woman</span><br>Person p1 = <span class="hljs-keyword">new</span> man();<br>Person p2 = <span class="hljs-keyword">new</span> woman();<br></code></pre></div></td></tr></table></figure></li><li>多态的使用有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际执行的是子类重写的父类的方法。总结：编译，看左边；运行，看右边</li><li>多态性的使用前提：<ul><li>类的继承关系</li><li>方法的重写</li></ul></li><li>注意：<ul><li>对象的多态之适用于方法，不适用于属性；对于属性而言，在编译期和运行期都看父类声明的属性。</li><li>多态性是运行时行为，不是编译时行为</li><li>重载不是多态，重写是多态</li></ul></li></ol><hr><h3 id="方法的重写"><a href="#方法的重写" class="headerlink" title="方法的重写"></a>方法的重写</h3><ol><li>判断两个函数是否为同一个函数：只需确定函数名与参数列表是否都一样</li><li>定义：子类对父类的某一方法进行重新改写。</li><li>注意：<ul><li>当子类对象调用该方法时，则调用的是自己重写的那个方法体；父类对象调用该方法时，则调用的是自己原来的那个方法体</li><li>子类重写的方法的权限修饰符范围不小于父类被重写的方法的权限修饰符</li><li>子类不能重写父类中声明为private权限的方法</li><li>子类重写的方法的返回值类型最好和父类保持一致</li><li>子类和父类中的同名同参的方法要么都声明为非static（这种情况才可以考虑重写），要么都声明为static的（这种情况肯定不是重写）</li></ul></li></ol><hr><h3 id="instanceof关键字："><a href="#instanceof关键字：" class="headerlink" title="instanceof关键字："></a>instanceof关键字：</h3><ol><li>使用：a instanceof A :表示对象a是否是类A的实例，如果是返回true，如果不是，返回false。若在类型强转前不先使用关键字判断一下，很有可能会出现类型转换异常。   </li></ol><hr><h3 id="equals和-的区别"><a href="#equals和-的区别" class="headerlink" title="equals和==的区别"></a>equals和==的区别</h3><ol><li>equals是一个方法，==是运算符</li><li>==可以使用在基本的数据类型变量和引用数据变量中，如果比较的是基本数据类型变量，则表示在比较两个变量保存的数据是否相等（相比较的两个变量的类型不一定要相同）；如果比较的是引用数据类型变量，则表示在比较两个对象的地址是否相同。而equals只能用于引用数据类型的变量，Object中定义的equals（）和==的作用是相同的，比较的是两个对象的地址值是否相同。</li></ol><ul><li>注意点：<ul><li>==运算符两边的数据类型要一致</li><li>像String、Date、File、包装类等都重写了Object类中的equals（）方法，重写之后，比较的不是两个引用的地址是否相同，而是比较两个对象的实体内容是否相同。</li><li>通常情况下，我们自定义的类如果使用equals的话，也通常是比较两个对象的“实体内容”是否相同，那么，我们就需要对Object类中的equals（）方法进行重写。</li><li>手写的equals（）重写实例：<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span></span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == obj)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> Customer)&#123;<br>    Customer cust = (Customer)obj;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.age == cust.age &amp;&amp; <span class="hljs-keyword">this</span>.name.equals(cust.name);<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>在实际的开发中，自动生成equals即可；</li></ul></li></ul><h3 id="Object类中的toString（）的使用"><a href="#Object类中的toString（）的使用" class="headerlink" title="Object类中的toString（）的使用"></a>Object类中的toString（）的使用</h3><ul><li>当我们输出一个对象的引用时，实际上是调用当前对象的toString（）</li><li>Object类中toString（）的定义<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">return</span> getClass().getName()+<span class="hljs-string">&quot;@&quot;</span>+Integer.toHex+String(hashcode());<br>&#125; <br></code></pre></div></td></tr></table></figure></li><li>像String、Date、File、包装类等都重写了Object类中的toString（）方法</li><li>自定义类也可以重写toString（）方法，当调用此方法时，返回对象实体内容，一般情况下则自动生成toString（）</li></ul><hr><h3 id="基本数据类型、包装类与String三者之间如何转换"><a href="#基本数据类型、包装类与String三者之间如何转换" class="headerlink" title="基本数据类型、包装类与String三者之间如何转换"></a>基本数据类型、包装类与String三者之间如何转换</h3><ol><li>基本数据类型—&gt;包装类（自动装箱）</li><li>包装类—&gt;基本数据类型（自动拆箱）<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Integer i = <span class="hljs-number">10</span>;<span class="hljs-comment">//自动装箱</span><br><span class="hljs-keyword">int</span> j = i;<span class="hljs-comment">//自动拆箱</span><br></code></pre></div></td></tr></table></figure></li><li>基本数据类型、包装类—&gt;String<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">int</span> num1 = <span class="hljs-number">10</span>;<br>  <span class="hljs-comment">//方式一：连接运算</span><br>  String str1 = num + <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-comment">//方式二：调用String的valueOf（Xxx xxx）</span><br>  <span class="hljs-keyword">float</span> f1 = <span class="hljs-number">12.3f</span>;<br>  String  str2 =  String.valueOf(f1);<span class="hljs-comment">//&quot;12.3&quot;</span><br>  Double  d1 = <span class="hljs-keyword">new</span> Double(<span class="hljs-number">12.4</span>);<br>  String str3 = String.valueOf(d1);<span class="hljs-comment">//&quot;12.4&quot;</span><br><br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>String类型—&gt;基本数据类型、包装类<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test5</span><span class="hljs-params">()</span></span>&#123;<br>  String str1 = <span class="hljs-string">&quot;123&quot;</span>;<br>  <span class="hljs-keyword">int</span> num2 = Integer.parseInt(str1);<span class="hljs-comment">//123</span><br>  String str2 = <span class="hljs-string">&quot;true&quot;</span>;<br>  <span class="hljs-keyword">boolean</span> b1 = Boolean.parseBoolean(str2);<span class="hljs-comment">//true</span><br>  String str3 = <span class="hljs-string">&quot;true1&quot;</span>;<br>  <span class="hljs-keyword">boolean</span> b1 = Boolean.parseBoolean(str3);<span class="hljs-comment">//false</span><br>&#125;<br></code></pre></div></td></tr></table></figure></li></ol><hr><h3 id="static-关键字的使用"><a href="#static-关键字的使用" class="headerlink" title="static 关键字的使用"></a>static 关键字的使用</h3><ol><li><p>static：静态的</p></li><li><p>static可以用来修饰属性、方法、代码块、内部类</p><ul><li>用来修饰属性（静态变量/类变量）<ul><li>属性：按是否使用static修饰又分为静态属性和非静态属性（也称为实例变量）。实例变量指我们创建了类的多个对象，每个对象都独立的拥有一套类中的非静态属性。当修改其中一个对象中非静态属性时，不会导致其他对象中同样的属性值的修改。静态变量是指我们创建了类的多个对象，多个对象共享同一个静态变量，当通过某一个对象修改静态变量是，会导致其他对象调用此静态变量时是修改过了的。</li><li>用来修饰属性的其他说明<ol><li>静态变量是随类的加载而加载的，可以通过“类.静态变量”的方式进行调用</li><li>静态变量的加载早于对象的创建</li><li>由于类只会加载一次，则静态变量在内存中也只会存一份，存在方法区的静态域中。</li></ol></li></ul></li><li>用来修饰方法（静态方法）</li></ul><ol><li>随着类的加载而加载，可以通过“类.静态方法”的方式进行调用</li><li>类不能调用非静态方法</li><li>在静态方法中，只能调用静态的方法或属性；在非静态方法中，既可以调用非静态的方法或属性，也可以调用静态的方法或属性</li></ol></li><li><p>static注意点</p><ul><li>在静态的方法中，不能使用this和super</li><li>从生命周期的角度理解静态属性和静态方法</li></ul></li><li><p>static应用</p><ul><li>开发中，如何确定一个属性是否要声明为static的？</li></ul><ol><li>属性是可以被多个对象所共享的，不会随着对象的不同而不同</li><li>类的常量也常常声明为static</li></ol><ul><li>开发中，如何确定一个方法是否要声明为static的？</li></ul><ol><li>操作静态属性的方法，通常设置为static</li><li>工具类中的方法，习惯上声明为static的，比如Math、Array、Collections</li></ol></li></ol><hr><h3 id="单利设计模式"><a href="#单利设计模式" class="headerlink" title="单利设计模式"></a>单利设计模式</h3><ul><li>饿汉式:对象加载的时间会更长；但线程安全<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonTest1</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(Sring[] args)</span></span>&#123;<br>    Bank bank1 = Bank.gerInstance();<br>  &#125;<br>  Class Bank&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">bank</span><span class="hljs-params">()</span></span>&#123;&#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Bank instance = <span class="hljs-keyword">new</span> Bank();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Bank <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>      <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>  &#125; <br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>懒汉式：延迟创建对象可减少加载时长，目前写的这个懒汉式是线程不安全的<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonTest2</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(Sring[] args)</span></span>&#123;<br>    Bank bank1 = Bank.gerInstance();<br>  &#125;<br>  Class Bank&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Bank</span><span class="hljs-params">()</span></span>&#123;&#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Bank instance = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Bank <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>      <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>)<br>      instance = <span class="hljs-keyword">new</span> Bank();<br>      <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>  &#125; <br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="类的成员之四（代码块或初始化块）"><a href="#类的成员之四（代码块或初始化块）" class="headerlink" title="类的成员之四（代码块或初始化块）"></a>类的成员之四（代码块或初始化块）</h3></li></ul><ol><li><p>作用：用来初始化类、对象</p></li><li><p>代码块只能用static来修饰，分为静态代码块和非静态代码块。</p><ul><li>静态代码块：</li><li>内部可以有输出语句随着类的加载而执行，只能执行一次。</li><li>用来初始化类的信息</li><li>非静态代码块：</li><li>内部可以输出语句</li><li>随着对象的创建而执行，没建一个对象就执行一次非静态代码块</li><li>可以再创建对象时，对对象的属性等进行初始化</li><li>若有多个非静态代码块，则按先后顺序执行</li></ul></li><li><p>代码块的结构：</p><ul><li>静态代码块：{}</li><li>非静态代码块：static{}</li></ul></li><li><p>静态代码块优先于非静态代码块执行，代码块优先于构造器执行</p></li><li><p>初始化的原则：由父及子，静态先行</p></li></ol><hr><h3 id="对属性可以赋值的位置"><a href="#对属性可以赋值的位置" class="headerlink" title="对属性可以赋值的位置"></a>对属性可以赋值的位置</h3><ol><li>默认初始化</li><li>显示初始化/在代码块中赋值</li><li>构造器初始化</li><li>有了对象之后，通过对象.属性或对象.方法的方式进行赋值</li><li>上述五点的执行顺序按1–&gt;2/5–&gt;3–&gt;4</li></ol><hr><h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><ol><li>final：最终的</li><li>final可用来修饰类、方法、变量</li><li>final用来修饰一个类：表此类不能被其他类继承，比如有String类、System类、StringBuffer类</li><li>final修饰方法：表明此方法不可以被重写，比如Object中的getClass（）</li><li>final修饰变量：此时的“变量”就称为是一个常量</li><li>final修饰属性，可以考虑赋值的位置有：显示初始化、代码块中初始化、构造器中初始化</li><li>final修饰局部变量：尤其是使用final修饰形参时，表明此形参是一个常量，当我们调用此方法是，给常量形参赋一个实参。一旦赋值以后就只能在方法体内使用此形参，但不能进行重新赋值</li><li>static final 用来把修饰属性：全局变量<h3 id="main方法："><a href="#main方法：" class="headerlink" title="main方法："></a>main方法：</h3></li><li>作为程序的入口</li><li>也是一个普遍的静态方法</li><li>可以作为我们与控制台交互的方式，如将控制台获取的数据传给形参：String[] args，当运行时，输入：java 类名 “Tom” “123” “true”即可，其中类名后面的就是传给形参的数据。<h3 id="abstract关键字"><a href="#abstract关键字" class="headerlink" title="abstract关键字"></a>abstract关键字</h3></li><li>abstract ：抽象的</li><li>abstract可以用来修饰类和方法</li><li>abstract修饰一个类：<ul><li>此类不能实例化</li><li>抽象类中一定有构造器，便于子类实例化调用（涉及子类实例化的全过程）</li><li>开发中，都会提供抽象类的子类，让子类去实例化，完成相关操作</li></ul></li><li>abstract修饰一个方法：<ul><li>抽象方法只能有方法的声明，没有方法体</li><li>包含抽象方法的类，一定是一个抽象类，反之，抽象类可以没有抽象方法</li><li>如子类重写了父类中的所有抽象方法后，此子类方可实例化，如子类没有重写父类中所有的抽象方法，则此类也是一个抽象类，需要使用abstract修饰。</li></ul></li><li>abstract使用上的注意点：<ul><li>abstract不能用来修饰：属性、构造器等结构。</li><li>abstract不能用来修饰私有方法、静态方法、final方法、final类</li></ul></li></ol><hr><h3 id="接口的使用"><a href="#接口的使用" class="headerlink" title="接口的使用"></a>接口的使用</h3><ol><li>关键字：interface</li><li>在java中，接口和类是并列的两个结构</li><li>如何定义接口，定义接口中的成员<ul><li>JDK7及以前：只能定义全局变量和抽象方法</li><li>全局常量：public static final的</li><li>抽象方法：public abstract的<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Flyable</span></span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_SPEED = <span class="hljs-number">7900</span>;<span class="hljs-comment">//全局变量，其中可以省略public static final，但它还在</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span></span>&#123;&#125;<span class="hljs-comment">//抽象方法，也可以省略public abstract</span><br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul></li><li>接口不能定义构造器：意味着接口不可以实例化</li><li>java开发中，接口通过类去实现（implement）的方式来使用，如果实现类覆盖了接口中的所有抽象方法，则此实现类就可以实例化，如果实现类没有覆盖接口中所有的抽象方法，则不能实例化。</li><li>java类可以实现多个接口，弥补了java单继承的局限性，格式：先写继承后写实现<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Class AA extends BB implements CC,DD<br></code></pre></div></td></tr></table></figure></li><li>接口与接口之间是继承，可以多继承</li><li>接口的具体使用，体现多态性</li><li>接口，实际上可以看做是一个规范</li><li>开发中，体会面向接口编程</li><li>在JDK8中，除了定义全局变量和抽象方法之外，还可以定义静态方法和默认方法：<ul><li>接口定义的静态方法，只能通过接口来调用</li><li>通过实现类的对象，可以调用接口中的默认方法，如果实现类重写了接口中的默认方法，调用时，仍然调用的是重写以后的方法。</li><li>如果子类（或实现类）继承的父类和实现的接口中含同名同参数的方法，那么子类在没有重写此方法的情况下，默认调用的是父类中的同名同参数的方法。（类优先原则）</li><li>如果实现类实现了多个接口，而这多个接口定义了同名同参数的默认方法，那么在实现类没有重写此方法的情况下，报错（接口冲突），这就需要我们必须在实现类中重写此方法。</li><li>如何在子类（或实现类）的方法中调用父类接口中被重写的方法<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Mythod</span><span class="hljs-params">()</span></span>&#123;<br>  method3();<span class="hljs-comment">//调用的是自己定义的重写的方法</span><br>  <span class="hljs-keyword">super</span>.method();<span class="hljs-comment">//调用的是父类中声明的</span><br>  接口名.<span class="hljs-keyword">super</span>.method();<span class="hljs-comment">//调用的是接口中默认的方法。</span><br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul></li></ol><hr><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><ol><li>java中允许将一个类A声明在另一个类B中，则类A就是内部类，类B称为外部类</li><li>内部类的分类：成员内部类和局部内部类<ul><li>成员内部类：类内可以定义属性、方法、构造器等，可以被final、abstract修饰；作为外部类的成员，可以调用外部类的结构，可以被static修饰</li><li>局部内部类：局部可以认为是在外部类中的构造器中、代码块中、方法体内</li></ul></li></ol><hr><h3 id="异常的体系结构"><a href="#异常的体系结构" class="headerlink" title="异常的体系结构"></a>异常的体系结构</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">java.lang.Throwable<br>      |_______java.lang.Error:一般不编写针对性的代码进行处理<br>      |_______java.lang.Exception:可以进行异常的处理<br>          |_______编译时异常（checkd）<br>              |_______IOException<br>                  |______FileNotFoundException<br>              |_______ClassNotFoundException<br>          |_______运行时异常（unchecked）<br>              |_______NullPointerException<br>              |_______ArrayIndexOutOfBoundsException<br>              |_______ClassCastException<br>              |_______NumberFormatException<br>              |_______InputMismatchException<br>              |_______ArithemticExdception<br></code></pre></div></td></tr></table></figure><ol><li>异常的处理：抓抛模型<ul><li>过程一：“抛”，程序正在执行的过程中，一旦出现异常，就会在异常代码处生成一个对应异常的对象，并将此对象抛出，一旦抛出对象以后，其后的代码就不再执行</li><li>关于异常对象的产生：</li><li>系统自动生成的异常对象</li><li>手动的生成一个异常对象</li><li>过程二：“抓”，可以理解为异常的处理方式</li><li>try-catch-finally</li><li>throws</li></ul></li><li>try-catch-finally的使用<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br><br>&#125;<span class="hljs-keyword">catch</span>(异常类型|变量名<span class="hljs-number">1</span>)&#123;<br><br>&#125;<span class="hljs-keyword">catch</span>(异常类型|变量名<span class="hljs-number">2</span>)&#123;<br><br>&#125;...<br><span class="hljs-keyword">finally</span>&#123;<br>  一定会执行的代码<br>&#125;<br><br></code></pre></div></td></tr></table></figure>使用说明：</li></ol><ul><li>finally是可选的</li><li>使用try将可能出现异常代码包装起来，在执行过程中，一旦出现异常，就会生成一个对应异常类的对象，根据此对象的类型，去catch中进行匹配</li><li>一旦try中的异常对象匹配到某一个catch时，就进入catch中进行异常的处理，一旦处理完成，就跳出当前的try-catch结构（在没有写finally的情况）继续执行其后的代码。</li><li>catch中的异常类型如果没有子父类关系，则谁声明在上，谁声明在下无所谓<br>catch的异常类型如果满足子父类关系，则要求子类一定声明在父类的上面，否则，报错</li><li>常用的异常对象处理方式：<ul><li>String getMessage（）</li><li>printStackTrace（）</li></ul></li><li>在try结构中声明的变量，再出了try结构以后，就不能在调用</li><li>在try-catch-finally处理编译时异常，使得程序在编译时不再报错，但是运行时仍然可能报错，相当于我们使用try-catch-finally将一个编译时可能出现的异常延迟到运行时出现</li><li>在开发中，由于运行时异常比较常见，所以我们通常就不针对运行时异常编写try-catch-finally了，针对编译时异常，一定要考虑异常的处理</li><li>finally的使用：<ul><li>finally中声明的是一定会被执行的代码，即使catch中又出现异常了。try中有return语句，catch中又return语句的情况</li><li>使用数据库连接、输入输出流、网络编程、socket等资源，jvm是不能自动的回收的。我们需要自己手动的进行的资源的释放。此时的资源释放，就需要声明在finally中</li></ul></li></ul><hr><h3 id="异常处理的方式二：throws-异常类型"><a href="#异常处理的方式二：throws-异常类型" class="headerlink" title="异常处理的方式二：throws + 异常类型"></a>异常处理的方式二：throws + 异常类型</h3><ol><li>“throws + 异常类型”写在方法的声明处。指明此方法执行时，可能会抛出的异常类型。一旦当方法体执行时出现异常，仍然在异常代码处生成一个异常类的对象，此对象满足throws后异常类型时，就会被抛出。异常代码后续的代码就不再执行了。</li><li>体会：try-catch-finally：真正的将异常给处理掉了；throws的方式知识将异常抛给了方法的调用者，并没有真正的将异常处理掉。</li><li>开发中，如何选择使用try-catch-finally，还是使用throws<ul><li>如果父类中被重写的方法没有throws方式处理异常，则子类重写的方法也不能使用throws，意味着如果子类重写的方法中有异常，必须使用try-catch-finally方式处理</li><li>执行的方法中，先后又调用了另外的几个方法，这几个方法是递进关系执行的，我们建议这几个方法使用throws</li></ul></li></ol><hr><h3 id="用户自定义异常"><a href="#用户自定义异常" class="headerlink" title="用户自定义异常"></a>用户自定义异常</h3><ol><li><p>如何自定义异常类</p><ul><li>继承于现有的异常结构：RuntimeException、Exception</li><li>提供全局变量：serialVersion</li><li>提供构造器</li></ul></li><li><p>throw与throws</p><ul><li>throw:表示抛出一个异常类的对象。生成异常对象的过程，声明在方法体内</li><li>throws：属于异常处理的一种方式，声明在方法的声明处</li></ul></li></ol><hr><h2 id="java高级"><a href="#java高级" class="headerlink" title="java高级"></a>java高级</h2><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><ol><li>多线程的创建的方式：<ul><li>方式一：继承于Thread类</li></ul><ol><li>创建一个继承Thread类的子类</li><li>重写Thread类的run()</li><li>创建Thread类的子类的对象</li><li>通过此对象调用start()</li></ol><ul><li>方式二：实现Runnable接口</li></ul><ol><li>创建一个实现了Runnable接口的类</li><li>实现类去实现Runnable中抽象方法：run();</li><li>创建实现类的对象</li><li>将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象</li><li>通过Thread类的对象调用start():启动线程–&gt;调用当前线程的run()–&gt;调用了Runnable类型的target的run();</li></ol></li><li>Thread中常用的方法<ul><li>start():启动当前线程，调用当前线程的run();</li><li>run():通过需要重写Thread类中的此方法，将创建的线程要执行的操作声明在方法中</li><li>currentThread():静态方法，返回执行当前代码的线程</li><li>getName():获取当前线程的名字</li><li>setName():设置当前线程的名字</li><li>yield():释放当前cpu的执行权</li><li>join():在线程a中调用线程b中的join(),此时线程a中就进入阻塞状态，知道线程b完全执行完以后，线程a才结束阻塞状态</li><li>stop():已过时，当执行此方法时，强制结束当前的线程</li><li>sleep(long millitime):让当前线程“睡眠”指定的毫秒数，在指定的睡眠时间内，当前线程是阻塞的</li></ul></li><li>比较创建线程的两种方式<ul><li>开发中：优先选择实现Runnable接口的方式，原因如下</li><li>实现的方式没有类的单继承的局限性</li><li>实现的方式更适合来处理多个线程有共享数据的情况</li><li>联系：Thread类也实现了Runnable接口</li><li>相同点：两种方式都需要重写run()，将线程要执行的逻辑声明在run()中</li></ul></li><li>线程的生命周期：如下图所示<br><img src="https://i.loli.net/2021/04/14/KAkCMOgtoqnN8zx.png" alt="线程生命周期图解"></li><li>线程的同步机制<ul><li>方式一：同步代码块<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (同步代码块)&#123;<br>  <span class="hljs-comment">//需要被同步的代码，操作共享数据的代码</span><br>&#125;<br><span class="hljs-comment">//说明:1.共享数据：多个线程共同操作的变量，例如抢的火车票就是共享数据。2.同步监视器，俗称锁，任何一个类的对象都可以用来充当锁。多个线程必须要共用统一把锁 3.在实现Runnable接口创建多线程的方式中，我们可以考虑使用this充当同步监视器。</span><br></code></pre></div></td></tr></table></figure></li></ul></li></ol><ul><li>方式二：同步方法–&gt;如果操作共享数据的代码完整的声明在一个方法中，我们不妨将此方法声明为同步的</li></ul><ol><li>同步方法仍然涉及到同步监视器，只是不需要我们显示的声明</li><li>非静态的同步方法，同步监视器是：this；静态的同步方法，同步监视器是当前类本身。</li></ol><ul><li>同步的方式解决了线程的安全问题。但操作同步代码时，只能有一个线程参与，其他线程等待，相当于是一个单线程的过程，效率低。</li><li>方式三：lock锁…jdk5.0新增</li><li>步骤：</li></ul><ol><li>实例化ReentrantLock</li><li>调用lock()方法</li><li>调用解决方法unlock()</li><li>将单例模式中的懒汉式进行改写–&gt;使用同步机制使其线程安全:方式一如下：<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function">Class <span class="hljs-title">Bank</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Bank</span><span class="hljs-params">()</span></span>&#123;&#125;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Bank instance = <span class="hljs-keyword">null</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Bank <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">//同步方法的方式</span><br>    <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>)&#123;<br>      instance = <span class="hljs-keyword">new</span> Bank();<br>    &#125;<br>    <span class="hljs-keyword">return</span> instance;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function">Class <span class="hljs-title">Bank</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Bank</span><span class="hljs-params">()</span></span>&#123;&#125;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Bank instance = <span class="hljs-keyword">null</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Bank <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">//同步代码块的方式</span><br>    <span class="hljs-keyword">synchronized</span> (Bank.class)&#123;<br>      <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>)&#123;<br>        instance = <span class="hljs-keyword">new</span> Bank();<br>    &#125;<br>      <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>   <br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>方式二如下：效率相较于上面的更高一些<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Bank <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>)&#123;<br>    <span class="hljs-keyword">synchronized</span> (Bank.class)&#123;<br>      <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>)&#123;<br>        instance = <span class="hljs-keyword">new</span> Bank();<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> instance;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>线程的死锁问题<ul><li>死锁的理解：不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁</li><li>说明：</li><li>出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续</li><li>我们使用同步时，要避免出现死锁</li><li>解决办法：</li><li>专门的算法、原则</li><li>尽量减少同步资源的定义</li><li>尽量避免嵌套同步</li></ul></li><li>面试题：synchronized与lock的异同<ul><li>相同：都能解决线程安全问题</li><li>不同：synchronized机制在执行相应的同步代码块以后，自动的释放同步监视器，lock需要手动的启动同步lock(),同时结束同步也需要手动的实现unlock()</li><li>三种解决同步问题的方式的优先选择顺序：lock–&gt;同步代码块–&gt;同步方法</li></ul></li></ol><hr><h3 id="线程的通信："><a href="#线程的通信：" class="headerlink" title="线程的通信："></a>线程的通信：</h3><ul><li>线程通信的例子，使用两个线程打印1-100.线程1、线程2交替打印</li><li>涉及到三个方法：<ul><li>wait():一旦执行此方法，当前线程就进入阻塞状态，并释放同步监视器</li><li>notify():一旦执行此方法，就会唤醒被wait的线程。如果有多个线程被wait，就唤醒优先级高的那个。</li><li>notifyAll():一旦执行此方法，就会唤醒所有被wait的线程</li><li>说明：上述三个方法使用在线程通信时，三个方法必须使用在同步代码块或同步方法中；方法的调用者必须是同步代码块或同步方法中的同步监视器，否则，或出现IllegalMonitorstateException异常；三个方法是定义在Java.lang.object类中</li></ul></li></ul><hr><ul><li>面试题：sleep()和wait()的异同<ul><li>相同点：一旦执行此方法，都可以是的当前线程进入阻塞状态</li><li>不同点：<ol><li>两个方法声明位置不同：Thread类中声明sleep(),Object类中声明wait()</li><li>调用的要求不同：sleep()可在任何需要的情景下调用，wait必须使用在同步代码块或同步方法中</li><li>关于是否释放同步监视器，如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，wait会释放锁。</li></ol></li></ul></li></ul><hr><h3 id="jdk5-0新增线程创建方式"><a href="#jdk5-0新增线程创建方式" class="headerlink" title="jdk5.0新增线程创建方式"></a>jdk5.0新增线程创建方式</h3><ul><li>新增方式一：实现callable接口<ol><li>创建一个实现callable的实现类</li><li>实现call方法，将此线程需要执行的操作声明在call中</li><li>创建callable接口实现类的对象</li><li>将此callable接口实现类的对象作为传递到futureTask构造器中，创建的futureTask的对象</li><li>将futureTask的对象作为参数，callable实现类重写的call()的返回值，并调用start()</li><li>获取callable中call方法的返回值</li></ol></li><li>如何解释实现callable接口的方式创建多线程比实现Runnable接口创建多线程方式强大。<ol><li>call()方法可以有返回值</li><li>call()可以抛出异常，被外面的操作捕获，获取异常的信息</li><li>callable是支持泛型的</li></ol></li><li>新增方式二：使用线程池（开发中常用）</li></ul><hr><p>Java常用类：</p><ul><li>String类<ol><li>String类：代表字符串，使用一对””引起来表示；属于final类，不可以被继承，内容存储在一个字符数组value[]中的；实现了serializable接口：表示字符串是支持序列化的；实现了comparable接口：表示string可以比较大小。</li><li>string代表不可变的字符序列，简称：不可变性。体现：当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。<br><code>String s1 = &quot;abc&quot;;//字面量的定义方式</code></li><li>通过字面量的方式（区别于new（））给一个字符串赋值，此时的字符串值声明在字符串常量池中</li><li>字符串常量池中是不会储存相同内容的字符串的</li><li>面试题：String s = new String(“abc”)方式创建对象，在内存中创建了几个对象？答：两个，一个是在堆空间中new的结构，另一个是char[]对应的常量池中的数据”abc”</li><li>String与char[]之间的转换</li></ol><ul><li>String–&gt;char[]:调用String的toCharArray()</li><li>char[]–&gt;String:调用String的构造器<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">String str1 = <span class="hljs-string">&quot;&quot;</span><br></code></pre></div></td></tr></table></figure></li></ul><ol start="7"><li>String与byte[]之间的转换</li></ol><ul><li>String–&gt;byte[]:调用String的getBytes(),该转换过程为编码过程</li><li>byte[]–&gt;String:String str = new String(bytes):使用默认的字符集进行解码</li></ul></li><li>结论：<ol><li>常量与常量的拼接结果在常量池。且常量池中不会存在相同内容的常量 </li><li>只要其中有一个是变量结果就在堆中</li><li>如果拼接的结果调用intern()方法，返回值就在常量池中。</li></ol></li><li>StringBuffer的常用方法：stringBuilder和StringBuffer的常用方法差不多。如下<ol><li>append(xxx):用于字符串的拼接</li><li>delete(int start,int end):删除指定位置的内容</li><li>replace(int start,int end,String str):吧[start,end]位置的字符串替换为str</li><li>insert(int offset,xxx):在指定位置插入xxx</li><li>reverse():把当前字符序列逆转</li><li>int indexof (String str):返回字符串首次出现的位置</li><li>StringsubString(int start,int end):返回String类型从start到end的字符串</li><li>int length(String str):返回字符串长度</li><li>char charAt(int n):返回某一位置的字符</li><li>void setChar(int n,char ch):将某一位置的字符设置为ch</li></ol></li><li>对比String、StringBuffer、StringBuilder三者的效率：从高到低排列：StringBuilder &gt; StringBuffer &gt; String</li><li>String、StringBuffer、StringBuilder三者的异同<ul><li>String为不可变的字符序列，而StringBuffer和StringBuilder都是可变的字符序列</li><li>三者都是底层使用char[]存储</li><li>StringBuilder和StringBuffer之间的异同：StringBuffer线程安全但效率低而StringBuilder则线程不安全但效率高；两者都存在扩容问题：如果要添加的数据底层数组盛不下了，那就需要扩容底层的数组。默认情况下，扩容为原来容量的2倍+2，同时将原有数组中的元素复制到新的数组中.</li><li>指导意见：开发中建议使用StringBuffer(int capacity)或StringBuilder(int capacity)</li></ul></li><li>jdk8之前的日期和时间api<ol><li>System类中的currentTimeMillis()<br><code>long time = System.currentTimeMillis();</code></li><li>数据库中的Date类<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">java.util.Date类<br>      |_____java.sql.Date类<br><span class="hljs-comment">//两个方法的使用： 1.toString()：显示当前的年月日时分秒</span><br><span class="hljs-comment">//                2.getTime():获取当前Date对象对应的毫秒数</span><br><span class="hljs-comment">//两个构造器的使用：1.Date date1 = new Date();创造一个对应当前时间的Date对象           2.Date date2 = new Date(1556324563L);创建指定毫秒数的Date对象</span><br></code></pre></div></td></tr></table></figure></li></ol></li><li>jdk8中新日期和时间api:java.time…<ul><li>时间接口主要的实现类：LocalDate(日期)、LocalTime(时间)、LocalDateTime(日期和时间)、DateTimeFormatter(日期和时间的格式)</li><li>时间类的使用，以LocalDateTimehe和DateTimeFormatter为例<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DateTimeFormatetTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        LocalDateTime localDateTime = LocalDateTime.now();<span class="hljs-comment">//获取当前的时间</span><br>        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<span class="hljs-comment">//为时间设置指定格式</span><br>        String str = localDateTime.format(formatter);<span class="hljs-comment">//将时间按指定格式转换，并返回一个结果的字符串</span><br>        System.out.println(str);<br>    &#125;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stringToLocalDateTime</span><span class="hljs-params">()</span></span>&#123;<br>        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<span class="hljs-comment">//设置时间为指定格式</span><br>        LocalDateTime localDateTime = LocalDateTime.parse(<span class="hljs-string">&quot;2021-04-17 14:43:10&quot;</span>,formatter);<span class="hljs-comment">//按指定格式解析传入的时间字符串</span><br>        System.out.println(localDateTime);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="Java比较器"><a href="#Java比较器" class="headerlink" title="Java比较器"></a>Java比较器</h3></li></ul></li><li>说明：Java中的对象，正常情况下，只能进行比较：==或!=,不能使用 &gt; 或 &lt; 的，但是在开发的场景中，我们需要对多个对象进行排序，言外之意，就需要比较对象的大小，如何实现？使用两个接口中的任何一个：comparable或comparator</li><li>comparable接口的使用<ul><li>像String、包装类等实现了comparable接口，重写了compareTo()方法，进行了从小到大的排列。</li><li>重写compareTo(obj)的规则</li></ul><ol><li>如果当前对象的this的某一属性大于形参obj的某一属性，则返回正整数。</li><li>同上，小于的话，返回负整数。</li><li>同上，等于的话，返回零。</li></ol></li><li>对于自定义类，如果需要排序，我们可以让自定义的类实现comparable接口，重写compareTo(obj)方法，在compareTo(obj)方法中指明按什么样的方式排序。例子如下：<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 指明人比较大小的方式：按年龄从小到大排序</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> Person) &#123;<br>            Person p = (Person) o;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.age &gt; p.age) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.age &lt; p.age)&#123;<br>                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;传入的数据类型不一致&quot;</span>);<br>    &#125;<br><span class="hljs-comment">//下面是测试用例</span><br><span class="hljs-meta">@Test</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>        Person[] per = <span class="hljs-keyword">new</span> Person[<span class="hljs-number">4</span>];<br>        per[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;lf&quot;</span>,<span class="hljs-number">24</span>);<br>        per[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;lw&quot;</span>,<span class="hljs-number">20</span>);<br>        per[<span class="hljs-number">2</span>] = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;lwz&quot;</span>,<span class="hljs-number">21</span>);<br>        per[<span class="hljs-number">3</span>] = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;lxz&quot;</span>,<span class="hljs-number">23</span>);<br>        Arrays.sort(per);<br>        System.out.println(Arrays.toString(per));<br>    &#125;<br></code></pre></div></td></tr></table></figure></li><li>comparator接口的使用：定制排序<ul><li>背景：当元素的类型没有实现java.lang.comparable接口而又不方便修改密码，或者实现了java.lang.comparable接口的排序规则不适合当前的操作</li><li>重写compare(Object o1,Object o2)方法，比较o1和o2的大小：如果返回正整数，则表示o1大于o2;返回负整数，表示小于；返回零，表示相等。</li><li>例子如下：<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;<br>       Person[] per = <span class="hljs-keyword">new</span> Person[<span class="hljs-number">5</span>];<br>       per[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;lf&quot;</span>,<span class="hljs-number">24</span>);<br>       per[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;fw&quot;</span>,<span class="hljs-number">21</span>);<br>       per[<span class="hljs-number">2</span>] = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;fw&quot;</span>,<span class="hljs-number">20</span>);<br>       per[<span class="hljs-number">3</span>] = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;xz&quot;</span>,<span class="hljs-number">23</span>);<br>       per[<span class="hljs-number">4</span>] = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;lz&quot;</span>,<span class="hljs-number">23</span>);<br>       Arrays.sort(per, <span class="hljs-keyword">new</span> Comparator() &#123;<br>           <span class="hljs-comment">//指明person比较大小的方式：先按照person的年龄从高到低排序，再按照person的姓名从低到高排序</span><br>           <span class="hljs-meta">@Override</span><br>           <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Object o1, Object o2)</span> </span>&#123;<br>               <span class="hljs-keyword">if</span> (o1 <span class="hljs-keyword">instanceof</span> Person &amp;&amp; o2 <span class="hljs-keyword">instanceof</span> Person) &#123;<br>                   Person p1 = (Person)o1;<br>                   Person p2 = (Person)o2;<br>                   <span class="hljs-keyword">if</span> (p1.getAge() == p2.getAge()) &#123;<br>                       <span class="hljs-keyword">return</span> p1.getName().compareTo(p2.getName());<br>                   &#125;<span class="hljs-keyword">else</span> &#123;<br>                       <span class="hljs-keyword">return</span> p1.compareTo(p2);<br>                   &#125;<br>               &#125;<br>               <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;传入的数据类型不一致&quot;</span>);<br>           &#125;<br>       &#125;);<br>       System.out.println(Arrays.toString(per));<br>   &#125;<br><br></code></pre></div></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java基本语法</title>
    <link href="/2021/03/21/java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    <url>/2021/03/21/java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="java基本语法"><a href="#java基本语法" class="headerlink" title="java基本语法"></a>java基本语法</h2><h2 id="标识符的命名规则"><a href="#标识符的命名规则" class="headerlink" title="标识符的命名规则"></a>标识符的命名规则</h2><ul><li>由26个大小写英文字母，0-9，_或$组成</li><li>数字不可以开头</li><li>不可以使用关键字和保留字，但能包含关键字和保留字</li><li>Java中严格区分大小写，长度无限制</li><li>标识符不能包含空格<h2 id="Java中的名称命名规范"><a href="#Java中的名称命名规范" class="headerlink" title="Java中的名称命名规范"></a>Java中的名称命名规范</h2></li><li>包名：多单词组成是所有字母都小写: xxxxyyyyyzzzz</li><li>类名、接口名：多单词组成时，所有单词的首字母大写：XxxxYyyyyZzzz</li><li>变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词的首字母都大写</li><li>常量名：所有字母都大写，多单词时每个单词用下划线连续:  XXX_YYY_ZZZ<h2 id="Java变量的使用"><a href="#Java变量的使用" class="headerlink" title="Java变量的使用"></a>Java变量的使用</h2></li><li>必须是要先声明、赋值之后，才可以使用。否则编译不通过</li><li>变量只能在作用域内起作用。<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3></li><li>整型：byte short int long     其中 long型赋值是须加上“l”或者“L”，若没加，则被机器识别为int型，但编译不会报错：例如 ：long a=1234 </li><li>浮点型： float double  其中float型赋值时必须加上“f”或者“F”，若没加，编译报错</li><li>字符型： char:    cahr c = ‘a’ –&gt; c=97      cahr c = ‘A’ –&gt; c=65</li><li>布尔型： Boolean：true/flase<br>特别的：整型常量 默认类型为int型，浮点型常量 默认类型为double型：例如：byte b = 12; byte b1 = b + 1;(会发生编译失败)–&gt;应改为 int b1= b + 1<br>浮点的例子类似<h3 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h3></li><li>String：</li><li>声明String类型的变量时。使用一对双引号“”<br>例：String s1 = “hello world”;<br>String s2 = “a”;<br>String s3 = “”; 三种都可以<br>与char相比 ,char c = ‘ ‘ 可以，但 char c =’’不可以，编译不通过</li><li>String可以和8种数据类型变量做运算，且运算只能是连接运算,通过+来连接 ，运算的结果仍是String类型 例如练习1</li><li>注意：当String和其他类型的变量做运算时，要区分“+”是代表加法运算还是连接运算：例如练习2和3<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//练习1</span><br><span class="hljs-keyword">int</span> number = <span class="hljs-number">1001</span>;<br>String numberStr = <span class="hljs-string">&quot;学号：&quot;</span>；<br>String info = numberStr + number;<span class="hljs-comment">// +：连接运算</span><br>Boolean b1 = <span class="hljs-keyword">true</span>;<br>String info1 = info + b1;<span class="hljs-comment">//+连接运算</span><br>System.out.println(info1);<span class="hljs-comment">//结果为：“学号：1001true”</span><br>--------------------------------------------------<br><span class="hljs-comment">//练习2</span><br><span class="hljs-keyword">char</span> c = <span class="hljs-string">&#x27;a&#x27;</span>;<br><span class="hljs-keyword">int</span> num = <span class="hljs-number">10</span>;<br>String str = <span class="hljs-string">&quot;hello&quot;</span>;<br>System.out.println(c + num + str);<span class="hljs-comment">//结果：107hello</span><br>System.out.println(c + str + num);<span class="hljs-comment">//结果：ahello10</span><br>----------------------------------------------------<br><span class="hljs-comment">//练习3</span><br>System.out.println(<span class="hljs-string">&quot;*   *&quot;</span>);<span class="hljs-comment">//结果：*  *</span><br>System.out.println(<span class="hljs-string">&#x27;*&#x27;</span> + <span class="hljs-string">&#x27;\t&#x27;</span> + <span class="hljs-string">&#x27;*&#x27;</span>);<span class="hljs-comment">//结果：93  42+9+42</span><br>System.out.println(<span class="hljs-string">&#x27;*&#x27;</span> + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&#x27;*&#x27;</span>);<span class="hljs-comment">//结果:*  *</span><br></code></pre></div></td></tr></table></figure><blockquote><h3 id="自动类型提升"><a href="#自动类型提升" class="headerlink" title="自动类型提升"></a>自动类型提升</h3></blockquote></li><li>结论：当容量小的数据类型的变量与容量大的数据类型的变量做运算时，结果自动提升为容量最大的数据类型。</li><li>-&gt; :  byte(1个字节)、char(2)、short(2)–&gt;int(4)–&gt;long(8)–&gt;float(4)–&gt;double(8)  特别的：当byte、char和short三种类型的变量做运算时，结果为int型。<blockquote><h3 id="强制类型转换："><a href="#强制类型转换：" class="headerlink" title="强制类型转换："></a>强制类型转换：</h3></blockquote></li><li>使用( ) 有可能会损失精度:例如：double a=12.3    double b=(int)a    结果为b=12<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3></li><li>%： 取余运算：结果的符号与被模数的符号相同</li><li>++、–：自增自减：注意点如下：<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">short</span> s1 = <span class="hljs-number">10</span>;<br>s1 = s1 + <span class="hljs-number">1</span>;<span class="hljs-comment">//会编译失败，因为s1加1之后为int型</span><br>s1 = (<span class="hljs-keyword">short</span>)(s1 + <span class="hljs-number">1</span>);<span class="hljs-comment">//编译正确</span><br>s1++;<span class="hljs-comment">//若直接s1++，自增1不会改变本身变量的数据类型</span><br><span class="hljs-comment">//同理：</span><br>s1 += <span class="hljs-number">2</span>;<span class="hljs-comment">//也不会改变变量自身的数据类型</span><br>改变两个变量的值<br><span class="hljs-comment">//方式一：定义临时变量</span><br><span class="hljs-keyword">int</span> num1 = <span class="hljs-number">10</span>,num2 = <span class="hljs-number">20</span>;<br><span class="hljs-keyword">int</span> temp = num1;<br>num1 = num2;<br>num2 = temp;<br><span class="hljs-comment">//方式二：两数相加; 虽然不用定义临时变量，但相加操作    可能会超出储存范围且只能适用于数值类型；</span><br>num1 = num1 + num2;<br>num2 = num1 - num2;<br>num1 =num1 - num2;<br><span class="hljs-comment">//方式三：使用位运算符； 也只能适用于数值类型 ：原理：一个数连续 ^ 上同一个数，结果等于它本身</span><br>num1 = num1 ^ num2;<br>num2 = num1 ^ num2;<br>num1 = num1 ^ num2;<br></code></pre></div></td></tr></table></figure><h2 id="获取一个随机数"><a href="#获取一个随机数" class="headerlink" title="获取一个随机数"></a>获取一个随机数</h2></li><li>获取一个在[a,b]范围的随机数公式： (int)(Math.random() * (b-a+1))+a<br>//如果要取一个[10-99]范围的随机数<br>int a = (int)(Math.random() * 90 +10)<br>break和continue的异同以及特殊情况</li><li>默认情况下：相同点：break和continue都是对最近一层循环起作用<br>不同点：break，跳出最近的整个循环；continue，结束当前循环的一次循环</li><li>特殊情况：可以指定break和continue作用于哪个循环；例子如下：<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">table:<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">3</span> ; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span> ; j &lt; i ; j++)&#123;<br>        System.out.println(*);<br>        <span class="hljs-keyword">continue</span> table;<span class="hljs-comment">//结束第一层循环的一次循环</span><br>    &#125;       <br>&#125;<br>table:<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">3</span> ; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span> ; j &lt; i ; j++)&#123;<br>        System.out.println(*);<br>        <span class="hljs-keyword">break</span> table;<span class="hljs-comment">//结束第一层循环</span><br>    &#125;       <br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="数组的基本操作"><a href="#数组的基本操作" class="headerlink" title="数组的基本操作"></a>数组的基本操作</h2></li><li>数组的复制、反转<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        String[] arr = <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;JJ&quot;</span>,<span class="hljs-string">&quot;DD&quot;</span>,<span class="hljs-string">&quot;MM&quot;</span>,<span class="hljs-string">&quot;BB&quot;</span>,<span class="hljs-string">&quot;GG&quot;</span>,<span class="hljs-string">&quot;AA&quot;</span>&#125;;<br>        <span class="hljs-comment">//数组的复制（区别于数组变量的赋值：arr1=arr）:相当于剪切操作</span><br>        String[] arr1 = <span class="hljs-keyword">new</span> String[arr.length];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr1.length; i++)&#123;<br>            arr1[i] = arr[i];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr1.length; i++) &#123;<br>            System.out.print(arr1[i]+<span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">//数组的反转1</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; arr.length / <span class="hljs-number">2</span>; i++)&#123;<br>            String temp = arr[i];<br>            arr[i] = arr[arr.length - i -<span class="hljs-number">1</span>];<br>            arr[arr.length -i -<span class="hljs-number">1</span>] = temp;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            System.out.print(arr[i]+<span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">//数组的反转2</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j =arr.length - <span class="hljs-number">1</span>;i &lt; j; i++, j--)&#123;<br>            String temp = arr[i];<br>            arr[i] = arr[j];<br>            arr[j] = temp;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            System.out.print(arr[i]+<span class="hljs-string">&quot;\t&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>数组的二分查找<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//二分法查找</span><br><span class="hljs-comment">//前提：所要查找的数组必须有序。</span><br><span class="hljs-keyword">int</span>[] arr2 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;-<span class="hljs-number">12</span>,-<span class="hljs-number">9</span>,-<span class="hljs-number">3</span>,-<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">45</span>,<span class="hljs-number">102</span>&#125;;<br><span class="hljs-keyword">int</span> dest = -<span class="hljs-number">2</span>;<br><span class="hljs-keyword">int</span> head = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> end = arr2.length - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">boolean</span> isFlag = <span class="hljs-keyword">true</span>;<br><span class="hljs-keyword">while</span>(head &lt;= end)&#123;<span class="hljs-comment">//注意是 &lt;=</span><br>    <span class="hljs-keyword">int</span> middle = (head + end) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(arr2[middle] == dest)&#123;<br>        System.out.println(<span class="hljs-string">&quot;元素找到，其位置为&quot;</span>+ middle);<br>        isFlag = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr2[middle] &lt; dest)&#123;<br>        head = middle + <span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">else</span><br>        end = middle - <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(isFlag)&#123;<br>    System.out.println(<span class="hljs-string">&quot;很遗憾没有找到！&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VScode终端填坑</title>
    <link href="/2021/03/03/VScode%E7%BB%88%E7%AB%AF%E5%A1%AB%E5%9D%91/"/>
    <url>/2021/03/03/VScode%E7%BB%88%E7%AB%AF%E5%A1%AB%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<h2 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h2><ul><li>使用PowerShell时报错：此系统禁止运行脚本<br><img src="https://i.loli.net/2021/03/03/ZUbRfrJay52N1Qg.png" alt="报错样图"></li></ul><hr><h2 id="快速解决方法"><a href="#快速解决方法" class="headerlink" title="快速解决方法:"></a>快速解决方法:</h2><ul><li>在VS code的PowerShell终端输入以下命令即可<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">Set-ExecutionPolicy RemoteSigned<br></code></pre></div></td></tr></table></figure></li><li>详细解决方案参考<a href="https://go.microsoft.com/fwlink/?LinkID=135170">这里</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>VScode PowerShell</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
